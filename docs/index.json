{
  "api/FastEndpoints.BaseEndpoint.html": {
    "href": "api/FastEndpoints.BaseEndpoint.html",
    "title": "Class BaseEndpoint | FastEndpoints",
    "keywords": "Class BaseEndpoint Inheritance System.Object BaseEndpoint Endpoint<TRequest, TResponse> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class BaseEndpoint : IEndpoint Fields _httpContext Declaration protected HttpContext _httpContext Field Value Type Description Microsoft.AspNetCore.Http.HttpContext Properties Configuration Declaration public EndpointDefinition Configuration { get; } Property Value Type Description EndpointDefinition HttpContext the http context of the current request Declaration public HttpContext HttpContext { get; } Property Value Type Description Microsoft.AspNetCore.Http.HttpContext ValidationFailures the list of validation failures for the current request dto Declaration public List<ValidationFailure> ValidationFailures { get; } Property Value Type Description List < FluentValidation.Results.ValidationFailure > Methods Configure() use this method to configure how the endpoint should be listening to incoming requests. HINT: it is only called once during endpoint auto registration during app startup. Declaration public virtual void Configure() Verbs(Http[]) Declaration public virtual void Verbs(params Http[] methods) Parameters Type Name Description Http [] methods"
  },
  "api/FastEndpoints.BindFromAttribute.html": {
    "href": "api/FastEndpoints.BindFromAttribute.html",
    "title": "Class BindFromAttribute | FastEndpoints",
    "keywords": "Class BindFromAttribute use this attribute to specify the name of route param, query param, or form field if it's different from the name of the property being bound to. Inheritance System.Object BindFromAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class BindFromAttribute : Attribute Constructors BindFromAttribute(String) use this attribute to specify the name of route param, query param, or form field if it's different from the name of the property being bound to. Declaration public BindFromAttribute(string name) Parameters Type Name Description System.String name the name to use for binding Properties Name the name of the incoming query param, route param or form field Declaration public string Name { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.Config.html": {
    "href": "api/FastEndpoints.Config.html",
    "title": "Class Config | FastEndpoints",
    "keywords": "Class Config global configuration settings for FastEndpoints Inheritance System.Object Config Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class Config Properties EndpointRegistrationFilter a function to filter out endpoints from auto registration. the function you set here will be executed for each endpoint during startup. you can inspect the EndpointSettings to check what the current endpoint is, if needed. return 'false' from the function if you want to exclude an endpoint from registration. return 'true' to include. this function will executed for each endpoint that has been discovered during startup. Declaration public Func<EndpointDefinition, bool> EndpointRegistrationFilter { set; } Property Value Type Description Func < EndpointDefinition , System.Boolean > ErrorResponseBuilder a function for transforming validation errors to an error response dto. set it to any func that returns an object that can be serialized to json. this function will be run everytime an error response needs to be sent to the client. the arguments for the func will be a collection of validation failures and an http status code. Declaration public Func<IEnumerable<ValidationFailure>, int, object> ErrorResponseBuilder { set; } Property Value Type Description Func < IEnumerable < FluentValidation.Results.ValidationFailure >, System.Int32 , System.Object > GlobalEndpointOptions an action to be performed on all endpoints during registration. the action you set here will be executed for each endpoint during startup. you can inspect the EndpointSettings to check what the current endpoint is, if needed. NOTE: this action is executed before Options() and Describe() of each individual endpoint. so, whatever you do here may get overridden or compounded by what you do in the Configure() method of each endpoint. Declaration public Action<EndpointDefinition, RouteHandlerBuilder> GlobalEndpointOptions { set; } Property Value Type Description Action < EndpointDefinition , Microsoft.AspNetCore.Builder.RouteHandlerBuilder > RequestDeserializer a function for deserializing the incoming http request body. this function will be executed for each request received if it has a json request body. the parameters of the func are as follows: HttpRequest: the incoming request Type: the type of the request dto which the request body will be deserialized into JsonSerializerContext?: json serializer context if code generation is used CancellationToken: a cancellation token Declaration public Func<HttpRequest, Type, JsonSerializerContext, CancellationToken, ValueTask<object>> RequestDeserializer { set; } Property Value Type Description Func < Microsoft.AspNetCore.Http.HttpRequest , Type , System.Text.Json.Serialization.JsonSerializerContext , CancellationToken , ValueTask < System.Object >> ResponseSerializer a function for writing serialized response dtos to the response body. this function will be executed whenever a json response is being sent to the client. you should set the content-type and write directly to the http response body stream in this function. the parameters of the func are as follows: HttpResponse: the http response object object: the response dto to be serialized string: the response content-type JsonSerializerContext?: json serializer context if code generation is used CancellationToken: a cancellation token config.ResponseSerializer = (rsp, dto, cType, jCtx , ct) => { rsp.ContentType = cType; return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct); }; Declaration public Func<HttpResponse, object, string, JsonSerializerContext, CancellationToken, Task> ResponseSerializer { set; } Property Value Type Description Func < Microsoft.AspNetCore.Http.HttpResponse , System.Object , System.String , System.Text.Json.Serialization.JsonSerializerContext , CancellationToken , Task > RoutingOptions routing options for all endpoints Declaration public Action<RoutingOptions> RoutingOptions { set; } Property Value Type Description Action < RoutingOptions > SerializerOptions settings for configuring the json serializer Declaration public Action<JsonSerializerOptions> SerializerOptions { set; } Property Value Type Description Action < System.Text.Json.JsonSerializerOptions > ShortEndpointNames set to true if you'd like the endpoint names/ swagger operation ids to be just the endpoint class names instead of the full names including namespace. Declaration public bool ShortEndpointNames { set; } Property Value Type Description System.Boolean VersioningOptions options for enabling endpoint versioning support Declaration public Action<VersioningOptions> VersioningOptions { set; } Property Value Type Description Action < VersioningOptions >"
  },
  "api/FastEndpoints.EmptyRequest.html": {
    "href": "api/FastEndpoints.EmptyRequest.html",
    "title": "Struct EmptyRequest | FastEndpoints",
    "keywords": "Struct EmptyRequest a request dto that doesn't have any properties Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public struct EmptyRequest"
  },
  "api/FastEndpoints.EmptyResponse.html": {
    "href": "api/FastEndpoints.EmptyResponse.html",
    "title": "Struct EmptyResponse | FastEndpoints",
    "keywords": "Struct EmptyResponse a response dto that doesn't have any properties Inherited Members System.ValueType.Equals(System.Object) System.ValueType.GetHashCode() System.ValueType.ToString() System.Object.Equals(System.Object, System.Object) System.Object.GetType() System.Object.ReferenceEquals(System.Object, System.Object) Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public struct EmptyResponse"
  },
  "api/FastEndpoints.Endpoint-1.html": {
    "href": "api/FastEndpoints.Endpoint-1.html",
    "title": "Class Endpoint<TRequest> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest> use this base class for defining endpoints that only use a request dto and don't use a response dto. Inheritance System.Object BaseEndpoint Endpoint <TRequest, System.Object > Endpoint<TRequest> EndpointWithoutRequest Inherited Members Endpoint<TRequest, Object>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, Object>.ExecuteAsync(TRequest, CancellationToken) Endpoint<TRequest, Object>.TryResolve<TService>() Endpoint<TRequest, Object>.TryResolve(Type) Endpoint<TRequest, Object>.Resolve<TService>() Endpoint<TRequest, Object>.Resolve(Type) Endpoint<TRequest, Object>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, Object>.Route<T>(String, Boolean) Endpoint<TRequest, Object>.Query<T>(String, Boolean) Endpoint<TRequest, Object>.OnBeforeValidate(TRequest) Endpoint<TRequest, Object>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, Object>.OnAfterValidate(TRequest) Endpoint<TRequest, Object>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, Object>.OnBeforeHandle(TRequest) Endpoint<TRequest, Object>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, Object>.OnAfterHandle(TRequest, Object) Endpoint<TRequest, Object>.OnAfterHandleAsync(TRequest, Object) Endpoint<TRequest, Object>.ValidationFailed Endpoint<TRequest, Object>.User Endpoint<TRequest, Object>.Response Endpoint<TRequest, Object>.Config Endpoint<TRequest, Object>.Env Endpoint<TRequest, Object>.Logger Endpoint<TRequest, Object>.BaseURL Endpoint<TRequest, Object>.HttpMethod Endpoint<TRequest, Object>.Form Endpoint<TRequest, Object>.Files Endpoint<TRequest, Object>.ResponseStarted Endpoint<TRequest, Object>.SendAsync(Object, Int32, CancellationToken) Endpoint<TRequest, Object>.SendCreatedAtAsync<TEndpoint>(Object, Object, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendCreatedAtAsync(String, Object, Object, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendStringAsync(String, Int32, String, CancellationToken) Endpoint<TRequest, Object>.SendOkAsync(Object, CancellationToken) Endpoint<TRequest, Object>.SendOkAsync(CancellationToken) Endpoint<TRequest, Object>.SendErrorsAsync(Int32, CancellationToken) Endpoint<TRequest, Object>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, Object>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, Object>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, Object>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, Object>.SendRedirectAsync(String, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, Object>.SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) Endpoint<TRequest, Object>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, Object>.Get(String[]) Endpoint<TRequest, Object>.Post(String[]) Endpoint<TRequest, Object>.Put(String[]) Endpoint<TRequest, Object>.Patch(String[]) Endpoint<TRequest, Object>.Delete(String[]) Endpoint<TRequest, Object>.Routes(String[]) Endpoint<TRequest, Object>.Verbs(Http[]) Endpoint<TRequest, Object>.DontThrowIfValidationFails() Endpoint<TRequest, Object>.DontAutoTag() Endpoint<TRequest, Object>.AllowAnonymous(Http[]) Endpoint<TRequest, Object>.AllowFileUploads() Endpoint<TRequest, Object>.AllowFormData() Endpoint<TRequest, Object>.Policies(String[]) Endpoint<TRequest, Object>.Roles(String[]) Endpoint<TRequest, Object>.Permissions(String[]) Endpoint<TRequest, Object>.PermissionsAll(String[]) Endpoint<TRequest, Object>.Claims(String[]) Endpoint<TRequest, Object>.ClaimsAll(String[]) Endpoint<TRequest, Object>.AuthSchemes(String[]) Endpoint<TRequest, Object>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, Object>.PostProcessors(IPostProcessor<TRequest, Object>[]) Endpoint<TRequest, Object>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, Object>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, Object>.Description(Action<RouteHandlerBuilder>, Boolean) Endpoint<TRequest, Object>.Summary(Action<EndpointSummary>) Endpoint<TRequest, Object>.Summary(Action<EndpointSummary<TRequest>>) Endpoint<TRequest, Object>.Summary(EndpointSummary) Endpoint<TRequest, Object>.Tags(String[]) Endpoint<TRequest, Object>.Version(Int32, Nullable<Int32>) Endpoint<TRequest, Object>.Throttle(Int32, Double, String) Endpoint<TRequest, Object>.SerializerContext<TContext>(TContext) Endpoint<TRequest, Object>.ScopedValidator() Endpoint<TRequest, Object>.RoutePrefixOverride(String) Endpoint<TRequest, Object>.AddError(String) Endpoint<TRequest, Object>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, Object>.ThrowIfAnyErrors() Endpoint<TRequest, Object>.ThrowError(String) Endpoint<TRequest, Object>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.Verbs(Http[]) BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest> : Endpoint<TRequest, object>, IEndpoint, IServiceResolver where TRequest : new() Type Parameters Name Description TRequest the type of the request dto"
  },
  "api/FastEndpoints.Endpoint-2.html": {
    "href": "api/FastEndpoints.Endpoint-2.html",
    "title": "Class Endpoint<TRequest, TResponse> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest, TResponse> use this base class for defining endpoints that use both request and response dtos. Inheritance System.Object BaseEndpoint Endpoint<TRequest, TResponse> Endpoint<TRequest> Endpoint<TRequest, TResponse, TMapper> EndpointWithMapping<TRequest, TResponse, TEntity> EndpointWithoutRequest<TResponse> Inherited Members BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest, TResponse> : BaseEndpoint, IEndpoint, IServiceResolver where TRequest : new() where TResponse : new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto Properties BaseURL the base url of the current request Declaration public string BaseURL { get; } Property Value Type Description System.String Config gives access to the configuration Declaration public IConfiguration Config { get; } Property Value Type Description Microsoft.Extensions.Configuration.IConfiguration Env gives access to the hosting environment Declaration public IWebHostEnvironment Env { get; } Property Value Type Description Microsoft.AspNetCore.Hosting.IWebHostEnvironment Files the files sent with the request. only populated when content-type is 'multipart/form-data' Declaration public IFormFileCollection Files { get; } Property Value Type Description Microsoft.AspNetCore.Http.IFormFileCollection Form the form sent with the request. only populated if content-type is 'application/x-www-form-urlencoded' or 'multipart/form-data' Declaration public IFormCollection Form { get; } Property Value Type Description Microsoft.AspNetCore.Http.IFormCollection HttpMethod the http method of the current request Declaration public Http HttpMethod { get; } Property Value Type Description Http Logger the logger for the current endpoint type Declaration public ILogger Logger { get; } Property Value Type Description Microsoft.Extensions.Logging.ILogger Response the response that is sent to the client. Declaration public TResponse Response { get; set; } Property Value Type Description TResponse ResponseStarted get or set whether the response has started. you'd only use this if you're writing to the response stream by yourself. Declaration public bool ResponseStarted { get; set; } Property Value Type Description System.Boolean User the current user principal Declaration public ClaimsPrincipal User { get; } Property Value Type Description System.Security.Claims.ClaimsPrincipal ValidationFailed indicates if there are any validation failures for the current request Declaration public bool ValidationFailed { get; } Property Value Type Description System.Boolean Methods AddError(Expression<Func<TRequest, Object>>, String) adds an error message for the specified property of the request dto Declaration protected void AddError(Expression<Func<TRequest, object>> property, string errorMessage) Parameters Type Name Description System.Linq.Expressions.Expression < Func <TRequest, System.Object >> property the property to add the error message for System.String errorMessage the error message AddError(String) adds a \"GeneralError\" to the current list of validation failures Declaration protected void AddError(string message) Parameters Type Name Description System.String message the error message AllowAnonymous(Http[]) allow unauthenticated requests to this endpoint. optionally specify a set of verbs to allow unauthenticated access with. i.e. if the endpoint is listening to POST, PUT & PATCH and you specify AllowAnonymous(Http.POST), then only PUT & PATCH will require authentication. Declaration protected void AllowAnonymous(params Http[] verbs) Parameters Type Name Description Http [] verbs AllowFileUploads() enable file uploads with multipart/form-data content type Declaration protected void AllowFileUploads() AllowFormData() enable multipart/form-data submissions Declaration protected void AllowFormData() AuthSchemes(String[]) specify which authentication schemes to use for authenticating requests to this endpoint Declaration protected void AuthSchemes(params string[] authSchemeNames) Parameters Type Name Description System.String [] authSchemeNames the authentication scheme names Claims(String[]) allows access if the claims principal has ANY of the given claim types Declaration protected void Claims(params string[] claimTypes) Parameters Type Name Description System.String [] claimTypes the claim types ClaimsAll(String[]) allows access if the claims principal has ALL of the given claim types Declaration protected void ClaimsAll(params string[] claimTypes) Parameters Type Name Description System.String [] claimTypes the claim types Delete(String[]) specify to listen for DELETE requests on one or more routes. Declaration protected void Delete(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Description(Action<RouteHandlerBuilder>, Boolean) describe openapi metadata for this endpoint. optionaly specify whether or not you want to clear the default Accepts/Produces metadata. EXAMPLE: b => b.Accepts<Request>(\"text/plain\") Declaration protected void Description(Action<RouteHandlerBuilder> builder, bool clearDefaults = false) Parameters Type Name Description Action < Microsoft.AspNetCore.Builder.RouteHandlerBuilder > builder the route handler builder for this endpoint System.Boolean clearDefaults set to true if the defaults should be cleared DontAutoTag() if swagger auto tagging based on path segment is enabled, calling this method will prevent a tag from being added to this endpoint. Declaration protected void DontAutoTag() DontThrowIfValidationFails() disable auto validation failure responses (400 bad request with error details) for this endpoint Declaration protected void DontThrowIfValidationFails() ExecuteAsync(TRequest, CancellationToken) the handler method for the endpoint that returns the response dto. this method is called for each request received. Declaration public virtual Task<TResponse> ExecuteAsync(TRequest req, CancellationToken ct) Parameters Type Name Description TRequest req the request dto CancellationToken ct a cancellation token Returns Type Description Task <TResponse> Get(String[]) specify to listen for GET requests on one or more routes. Declaration protected void Get(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns HandleAsync(TRequest, CancellationToken) the handler method for the endpoint. this method is called for each request received. Declaration public virtual Task HandleAsync(TRequest req, CancellationToken ct) Parameters Type Name Description TRequest req the request dto CancellationToken ct a cancellation token Returns Type Description Task OnAfterHandle(TRequest, TResponse) override this method if you'd like to do something after the handler is executed. Declaration public virtual void OnAfterHandle(TRequest req, TResponse res) Parameters Type Name Description TRequest req the request dto TResponse res the response dto that was sent to the client OnAfterHandleAsync(TRequest, TResponse) override this method if you'd like to do something after the handler is executed. Declaration public virtual Task OnAfterHandleAsync(TRequest req, TResponse res) Parameters Type Name Description TRequest req the request dto TResponse res the response dto that was sent to the client Returns Type Description Task OnAfterValidate(TRequest) override this method if you'd like to do something to the request dto after it gets validated. Declaration public virtual void OnAfterValidate(TRequest req) Parameters Type Name Description TRequest req the request dto OnAfterValidateAsync(TRequest) override this method if you'd like to do something to the request dto after it gets validated. Declaration public virtual Task OnAfterValidateAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task OnBeforeHandle(TRequest) override this method if you'd like to do something to the request dto before the handler is executed. Declaration public virtual void OnBeforeHandle(TRequest req) Parameters Type Name Description TRequest req the request dto OnBeforeHandleAsync(TRequest) override this method if you'd like to do something to the request dto before the handler is executed. Declaration public virtual Task OnBeforeHandleAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task OnBeforeValidate(TRequest) override this method if you'd like to do something to the request dto before it gets validated. Declaration public virtual void OnBeforeValidate(TRequest req) Parameters Type Name Description TRequest req the request dto OnBeforeValidateAsync(TRequest) override this method if you'd like to do something to the request dto before it gets validated. Declaration public virtual Task OnBeforeValidateAsync(TRequest req) Parameters Type Name Description TRequest req the request dto Returns Type Description Task Options(Action<RouteHandlerBuilder>) set endpoint configurations options using an endpoint builder action /// Declaration protected void Options(Action<RouteHandlerBuilder> builder) Parameters Type Name Description Action < Microsoft.AspNetCore.Builder.RouteHandlerBuilder > builder the builder for this endpoint Patch(String[]) specify to listen for PATCH requests on one or more routes. Declaration protected void Patch(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Permissions(String[]) allows access if the claims principal has ANY of the given permissions Declaration protected void Permissions(params string[] permissions) Parameters Type Name Description System.String [] permissions the permissions PermissionsAll(String[]) allows access if the claims principal has ALL of the given permissions Declaration protected void PermissionsAll(params string[] permissions) Parameters Type Name Description System.String [] permissions the permissions Policies(String[]) specify one or more authorization policy names you have added to the middleware pipeline during app startup/ service configuration that should be applied to this endpoint. Declaration protected void Policies(params string[] policyNames) Parameters Type Name Description System.String [] policyNames one or more policy names (must have been added to the pipeline on startup) Post(String[]) specify to listen for POST requests on one or more routes. Declaration protected void Post(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns PostProcessors(IPostProcessor<TRequest, TResponse>[]) configure a collection of post-processors to be executed after the main handler function is done. processors are executed in the order they are defined here. Declaration protected void PostProcessors(params IPostProcessor<TRequest, TResponse>[] postProcessors) Parameters Type Name Description IPostProcessor <TRequest, TResponse>[] postProcessors the post processors to be executed PreProcessors(IPreProcessor<TRequest>[]) configure a collection of pre-processors to be executed before the main handler function is called. processors are executed in the order they are defined here. Declaration protected void PreProcessors(params IPreProcessor<TRequest>[] preProcessors) Parameters Type Name Description IPreProcessor <TRequest>[] preProcessors the pre processors to be executed PublishAsync<TEvent>(TEvent, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public Task PublishAsync<TEvent>(TEvent eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) where TEvent : class Parameters Type Name Description TEvent eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work. Type Parameters Name Description TEvent Put(String[]) specify to listen for PUT requests on one or more routes. Declaration protected void Put(params string[] routePatterns) Parameters Type Name Description System.String [] routePatterns Query<T>(String, Boolean) get the value of a given query parameter by specifying the resulting type and query parameter name. NOTE: an automatic validation error is sent to the client when value retrieval is not successful. Declaration protected T Query<T>(string paramName, bool isRequired = true) Parameters Type Name Description System.String paramName query parameter name System.Boolean isRequired set to false for disabling the automatic validation error Returns Type Description T the value if retrieval is successful or null if isRequired is set to false Type Parameters Name Description T type of the result Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) specify response caching settings for this endpoint Declaration protected void ResponseCache(int durationSeconds, ResponseCacheLocation location = ResponseCacheLocation.Any, bool noStore = false, string varyByHeader = null, string[] varyByQueryKeys = null) Parameters Type Name Description System.Int32 durationSeconds the duration in seconds for which the response is cached Microsoft.AspNetCore.Mvc.ResponseCacheLocation location the location where the data from a particular URL must be cached System.Boolean noStore specify whether the data should be stored or not System.String varyByHeader the value for the Vary response header System.String [] varyByQueryKeys the query keys to vary by Roles(String[]) allows access if the claims principal has ANY of the given roles Declaration protected void Roles(params string[] rolesNames) Parameters Type Name Description System.String [] rolesNames one or more roles that has access Route<T>(String, Boolean) get the value of a given route parameter by specifying the resulting type and param name. NOTE: an automatic validation error is sent to the client when value retrieval is not successful. Declaration protected T Route<T>(string paramName, bool isRequired = true) Parameters Type Name Description System.String paramName route parameter name System.Boolean isRequired set to false for disabling the automatic validation error Returns Type Description T the value if retrieval is successful or null if isRequired is set to false Type Parameters Name Description T type of the result RoutePrefixOverride(String) specify an override route prefix for this endpoint if a global route prefix is enabled. this is ignored if a global route prefix is not configured. global prefix can be ignored by setting string.Empty Declaration protected void RoutePrefixOverride(string routePrefix) Parameters Type Name Description System.String routePrefix route prefix value Routes(String[]) specify one or more route patterns this endpoint should be listening for Declaration protected void Routes(params string[] patterns) Parameters Type Name Description System.String [] patterns ScopedValidator() register the validator for this endpoint as scoped instead of singleton. which will enable constructor injection at the cost of performance. Declaration protected void ScopedValidator() SendAsync(TResponse, Int32, CancellationToken) send the supplied response dto serialized as json to the client. Declaration protected Task SendAsync(TResponse response, int statusCode = 200, CancellationToken cancellation = null) Parameters Type Name Description TResponse response the object to serialize to json System.Int32 statusCode optional custom http status code CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send a byte array to the client Declaration protected Task SendBytesAsync(byte[] bytes, string fileName = null, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description System.Byte [] bytes the bytes to send System.String fileName System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendCreatedAtAsync(String, Object, TResponse, Boolean, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration protected Task SendCreatedAtAsync(string endpointName, object routeValues, TResponse responseBody, bool generateAbsoluteUrl = false, CancellationToken cancellation = null) Parameters Type Name Description System.String endpointName the name of the endpoint to use for link generation (openapi route id) System.Object routeValues a route values object with key/value pairs of route information TResponse responseBody the content to be serialized in the response body System.Boolean generateAbsoluteUrl set to true for generating a absolute url instead of relative url for the location header CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendCreatedAtAsync<TEndpoint>(Object, TResponse, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint, specify the 'routeNumber' argument. WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload that accepts a string endpoint name instead. Declaration protected Task SendCreatedAtAsync<TEndpoint>(object routeValues, TResponse responseBody, Http? verb = null, int? routeNumber = null, bool generateAbsoluteUrl = false, CancellationToken cancellation = null) where TEndpoint : IEndpoint Parameters Type Name Description System.Object routeValues a route values object with key/value pairs of route information TResponse responseBody the content to be serialized in the response body System.Nullable < Http > verb only useful when pointing to a multi verb endpoint System.Nullable < System.Int32 > routeNumber only useful when pointing to a multi route endpoint System.Boolean generateAbsoluteUrl set to true for generating a absolute url instead of relative url for the location header CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task Type Parameters Name Description TEndpoint the type of the endpoint where the resource can be retrieved from SendEmptyJsonObject(CancellationToken) send an empty json object in the body Declaration protected Task SendEmptyJsonObject(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendErrorsAsync(Int32, CancellationToken) send a 400 bad request with error details of the current validation failures Declaration protected Task SendErrorsAsync(int statusCode = 400, CancellationToken cancellation = null) Parameters Type Name Description System.Int32 statusCode the status code for the error response CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) start a \"server-sent-events\" data stream for the client asynchronously without blocking any threads Declaration protected Task SendEventStreamAsync<T>(string eventName, IAsyncEnumerable<T> eventStream, CancellationToken cancellation = null) Parameters Type Name Description System.String eventName the name of the event stream IAsyncEnumerable <T> eventStream an IAsyncEnumerable that is the source of the data CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task Type Parameters Name Description T the type of the objects being sent in the event stream SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send a file to the client Declaration protected Task SendFileAsync(FileInfo fileInfo, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description FileInfo fileInfo System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendForbiddenAsync(CancellationToken) send a 403 unauthorized response Declaration protected Task SendForbiddenAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendNoContentAsync(CancellationToken) send a 204 no content response Declaration protected Task SendNoContentAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendNotFoundAsync(CancellationToken) send a 404 not found response Declaration protected Task SendNotFoundAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendOkAsync(TResponse, CancellationToken) send an http 200 ok response with the supplied response dto serialized as json to the client. Declaration protected Task SendOkAsync(TResponse response, CancellationToken cancellation = null) Parameters Type Name Description TResponse response the object to serialize to json CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendOkAsync(CancellationToken) send an http 200 ok response without any body Declaration protected Task SendOkAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendRedirectAsync(String, Boolean, CancellationToken) send a 301/302 redirect response Declaration protected Task SendRedirectAsync(string location, bool isPermanant = false, CancellationToken cancellation = null) Parameters Type Name Description System.String location the location to redirect to System.Boolean isPermanant set to true for a 302 redirect. 301 is the default. CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send the contents of a stream to the client Declaration protected Task SendStreamAsync(Stream stream, string fileName = null, long? fileLengthBytes = null, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description Stream stream the stream to read the data from System.String fileName and optional file name to set in the content-disposition header System.Nullable < System.Int64 > fileLengthBytes optional total size of the file/stream System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendStringAsync(String, Int32, String, CancellationToken) send the supplied string content to the client. Declaration protected Task SendStringAsync(string content, int statusCode = 200, string contentType = \"text/plain\", CancellationToken cancellation = null) Parameters Type Name Description System.String content the string to write to the response body System.Int32 statusCode optional custom http status code System.String contentType optional content type header value CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SendUnauthorizedAsync(CancellationToken) send a 401 unauthorized response Declaration protected Task SendUnauthorizedAsync(CancellationToken cancellation = null) Parameters Type Name Description CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used Returns Type Description Task SerializerContext<TContext>(TContext) specify the json serializer context if code generation for request/response dtos is being used Declaration protected void SerializerContext<TContext>(TContext serializerContext) where TContext : JsonSerializerContext Parameters Type Name Description TContext serializerContext Type Parameters Name Description TContext the type of the json serializer context for this endpoint Summary(Action<EndpointSummary<TRequest>>) provide a summary/description for this endpoint to be used in swagger/ openapi Declaration protected void Summary(Action<EndpointSummary<TRequest>> endpointSummary) Parameters Type Name Description Action < EndpointSummary <TRequest>> endpointSummary an action that sets values of an endpoint summary object Summary(Action<EndpointSummary>) provide a summary/description for this endpoint to be used in swagger/ openapi Declaration protected void Summary(Action<EndpointSummary> endpointSummary) Parameters Type Name Description Action < EndpointSummary > endpointSummary an action that sets values of an endpoint summary object Summary(EndpointSummary) provide a summary/description for this endpoint to be used in swagger/ openapi Declaration protected void Summary(EndpointSummary endpointSummary) Parameters Type Name Description EndpointSummary endpointSummary an endpoint summary instance Tags(String[]) specify one or more string tags for this endpoint so they can be used in the exclusion filter during registration. HINT: these tags have nothing to do with swagger tags! Declaration protected void Tags(params string[] endpointTags) Parameters Type Name Description System.String [] endpointTags the tag values to associate with this endpoint Throttle(Int32, Double, String) rate limit requests to this endpoint based on a request http header sent by the client. Declaration protected void Throttle(int hitLimit, double durationSeconds, string headerName = null) Parameters Type Name Description System.Int32 hitLimit how many requests are allowed within the given duration System.Double durationSeconds the frequency in seconds where the accrued hit count should be reset System.String headerName the name of the request header used to uniquely identify clients. specifying null will first look for 'X-Forwarded-For' and if not present, will use HttpContext.Connection.RemoteIpAddress ThrowError(Expression<Func<TRequest, Object>>, String) adds an error message for the specified property of the request dto and sends back a 400 bad request with error details immediately interrupting handler execution flow. no execution will continue past this call. Declaration protected void ThrowError(Expression<Func<TRequest, object>> property, string errorMessage) Parameters Type Name Description System.Linq.Expressions.Expression < Func <TRequest, System.Object >> property the property to add the error message for System.String errorMessage the error message ThrowError(String) add a \"GeneralError\" to the validation failure list and send back a 400 bad request with error details immediately interrupting handler execution flow. if there are any vallidation failures, no execution will continue past this call. Declaration protected void ThrowError(string message) Parameters Type Name Description System.String message the error message ThrowIfAnyErrors() interrupt the flow of handler execution and send a 400 bad request with error details if there are any validation failures in the current request. if there are no validation failures, execution will continue past this call. Declaration protected void ThrowIfAnyErrors() TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Verbs(Http[]) specify one or more http method verbs this endpoint should be accepting requests for Declaration public sealed override void Verbs(params Http[] methods) Parameters Type Name Description Http [] methods Overrides BaseEndpoint.Verbs(Http[]) Version(Int32, Nullable<Int32>) specify the version of the endpoint if versioning is enabled Declaration protected void Version(int version, int? deprecateAt = null) Parameters Type Name Description System.Int32 version the version of this endpoint System.Nullable < System.Int32 > deprecateAt the version group number starting at which this endpoint should not be included in swagger"
  },
  "api/FastEndpoints.Endpoint-3.html": {
    "href": "api/FastEndpoints.Endpoint-3.html",
    "title": "Class Endpoint<TRequest, TResponse, TMapper> | FastEndpoints",
    "keywords": "Class Endpoint<TRequest, TResponse, TMapper> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity using a seperate entity mapper. Inheritance System.Object BaseEndpoint Endpoint <TRequest, TResponse> Endpoint<TRequest, TResponse, TMapper> Inherited Members Endpoint<TRequest, TResponse>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.ExecuteAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.TryResolve<TService>() Endpoint<TRequest, TResponse>.TryResolve(Type) Endpoint<TRequest, TResponse>.Resolve<TService>() Endpoint<TRequest, TResponse>.Resolve(Type) Endpoint<TRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, TResponse>.Route<T>(String, Boolean) Endpoint<TRequest, TResponse>.Query<T>(String, Boolean) Endpoint<TRequest, TResponse>.OnBeforeValidate(TRequest) Endpoint<TRequest, TResponse>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidate(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandle(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterHandle(TRequest, TResponse) Endpoint<TRequest, TResponse>.OnAfterHandleAsync(TRequest, TResponse) Endpoint<TRequest, TResponse>.ValidationFailed Endpoint<TRequest, TResponse>.User Endpoint<TRequest, TResponse>.Response Endpoint<TRequest, TResponse>.Config Endpoint<TRequest, TResponse>.Env Endpoint<TRequest, TResponse>.Logger Endpoint<TRequest, TResponse>.BaseURL Endpoint<TRequest, TResponse>.HttpMethod Endpoint<TRequest, TResponse>.Form Endpoint<TRequest, TResponse>.Files Endpoint<TRequest, TResponse>.ResponseStarted Endpoint<TRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendStringAsync(String, Int32, String, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendErrorsAsync(Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendRedirectAsync(String, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) Endpoint<TRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, TResponse>.Get(String[]) Endpoint<TRequest, TResponse>.Post(String[]) Endpoint<TRequest, TResponse>.Put(String[]) Endpoint<TRequest, TResponse>.Patch(String[]) Endpoint<TRequest, TResponse>.Delete(String[]) Endpoint<TRequest, TResponse>.Routes(String[]) Endpoint<TRequest, TResponse>.Verbs(Http[]) Endpoint<TRequest, TResponse>.DontThrowIfValidationFails() Endpoint<TRequest, TResponse>.DontAutoTag() Endpoint<TRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<TRequest, TResponse>.AllowFileUploads() Endpoint<TRequest, TResponse>.AllowFormData() Endpoint<TRequest, TResponse>.Policies(String[]) Endpoint<TRequest, TResponse>.Roles(String[]) Endpoint<TRequest, TResponse>.Permissions(String[]) Endpoint<TRequest, TResponse>.PermissionsAll(String[]) Endpoint<TRequest, TResponse>.Claims(String[]) Endpoint<TRequest, TResponse>.ClaimsAll(String[]) Endpoint<TRequest, TResponse>.AuthSchemes(String[]) Endpoint<TRequest, TResponse>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, TResponse>.PostProcessors(IPostProcessor<TRequest, TResponse>[]) Endpoint<TRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Description(Action<RouteHandlerBuilder>, Boolean) Endpoint<TRequest, TResponse>.Summary(Action<EndpointSummary>) Endpoint<TRequest, TResponse>.Summary(Action<EndpointSummary<TRequest>>) Endpoint<TRequest, TResponse>.Summary(EndpointSummary) Endpoint<TRequest, TResponse>.Tags(String[]) Endpoint<TRequest, TResponse>.Version(Int32, Nullable<Int32>) Endpoint<TRequest, TResponse>.Throttle(Int32, Double, String) Endpoint<TRequest, TResponse>.SerializerContext<TContext>(TContext) Endpoint<TRequest, TResponse>.ScopedValidator() Endpoint<TRequest, TResponse>.RoutePrefixOverride(String) Endpoint<TRequest, TResponse>.AddError(String) Endpoint<TRequest, TResponse>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, TResponse>.ThrowIfAnyErrors() Endpoint<TRequest, TResponse>.ThrowError(String) Endpoint<TRequest, TResponse>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.Verbs(Http[]) BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Endpoint<TRequest, TResponse, TMapper> : Endpoint<TRequest, TResponse>, IEndpoint, IServiceResolver where TRequest : new() where TResponse : new() where TMapper : IEntityMapper, new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto TMapper the type of the entity mapper Properties Map the entity mapper for the endpoint HINT: entity mappers are singletons for performance reasons. do not maintain state in the mappers. Declaration public static TMapper Map { get; } Property Value Type Description TMapper"
  },
  "api/FastEndpoints.EndpointDefinition.html": {
    "href": "api/FastEndpoints.EndpointDefinition.html",
    "title": "Class EndpointDefinition | FastEndpoints",
    "keywords": "Class EndpointDefinition represents the configuration settings of an endpoint Inheritance System.Object EndpointDefinition Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class EndpointDefinition Properties AllowAnyClaim Declaration public bool AllowAnyClaim { get; } Property Value Type Description System.Boolean AllowAnyPermission Declaration public bool AllowAnyPermission { get; } Property Value Type Description System.Boolean AllowFormData Declaration public bool AllowFormData { get; } Property Value Type Description System.Boolean AnonymousVerbs Declaration public string[] AnonymousVerbs { get; } Property Value Type Description System.String [] AuthSchemes Declaration public string[] AuthSchemes { get; } Property Value Type Description System.String [] ClaimTypes Declaration public string[] ClaimTypes { get; } Property Value Type Description System.String [] DontAutoTag Declaration public bool DontAutoTag { get; } Property Value Type Description System.Boolean Permissions Declaration public string[] Permissions { get; } Property Value Type Description System.String [] PreBuiltUserPolicies Declaration public string[] PreBuiltUserPolicies { get; } Property Value Type Description System.String [] Roles Declaration public string[] Roles { get; } Property Value Type Description System.String [] RoutePrefixOverride Declaration public string RoutePrefixOverride { get; } Property Value Type Description System.String Routes Declaration public string[] Routes { get; } Property Value Type Description System.String [] SecurityPolicyName Declaration public string SecurityPolicyName { get; } Property Value Type Description System.String Summary Declaration public EndpointSummary Summary { get; } Property Value Type Description EndpointSummary Tags Declaration public string[] Tags { get; } Property Value Type Description System.String [] ThrowIfValidationFails Declaration public bool ThrowIfValidationFails { get; } Property Value Type Description System.Boolean Verbs Declaration public string[] Verbs { get; } Property Value Type Description System.String [] Version Declaration public EpVersion Version { get; } Property Value Type Description EpVersion"
  },
  "api/FastEndpoints.EndpointSummary.html": {
    "href": "api/FastEndpoints.EndpointSummary.html",
    "title": "Class EndpointSummary | FastEndpoints",
    "keywords": "Class EndpointSummary a class used for providing a textual description about an endpoint for swagger Inheritance System.Object EndpointSummary EndpointSummary<TRequest> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class EndpointSummary Properties Description the long description of the endpoint Declaration public string Description { get; set; } Property Value Type Description System.String Item[Int32] indexer for the response descriptions Declaration public string this[int statusCode] { get; set; } Parameters Type Name Description System.Int32 statusCode the status code of the response you want to access Property Value Type Description System.String the text description Params the descriptions for endpoint paramaters. you can add descriptions for route/query params and request dto properties. what you specify here will take precedence over xml comments of dto classes (if they are also specified). Declaration public Dictionary<string, string> Params { get; set; } Property Value Type Description Dictionary < System.String , System.String > Responses the descriptions of the different responses/ status codes an endpoint can return Declaration public Dictionary<int, string> Responses { get; set; } Property Value Type Description Dictionary < System.Int32 , System.String > Summary the short summary of the endpoint Declaration public string Summary { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.EndpointSummary-1.html": {
    "href": "api/FastEndpoints.EndpointSummary-1.html",
    "title": "Class EndpointSummary<TRequest> | FastEndpoints",
    "keywords": "Class EndpointSummary<TRequest> Inheritance System.Object EndpointSummary EndpointSummary<TRequest> Inherited Members EndpointSummary.Summary EndpointSummary.Description EndpointSummary.Responses EndpointSummary.Params EndpointSummary.Item[Int32] System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class EndpointSummary<TRequest> : EndpointSummary where TRequest : new() Type Parameters Name Description TRequest the type of the request dto Methods RequestParam(Expression<Func<TRequest, Object>>, String) add a description for a request param for a given property of the request dto Declaration public void RequestParam(Expression<Func<TRequest, object>> property, string description) Parameters Type Name Description System.Linq.Expressions.Expression < Func <TRequest, System.Object >> property a member expression for specifying which property the description is for System.String description the description text"
  },
  "api/FastEndpoints.EndpointWithMapping-3.html": {
    "href": "api/FastEndpoints.EndpointWithMapping-3.html",
    "title": "Class EndpointWithMapping<TRequest, TResponse, TEntity> | FastEndpoints",
    "keywords": "Class EndpointWithMapping<TRequest, TResponse, TEntity> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity. Inheritance System.Object BaseEndpoint Endpoint <TRequest, TResponse> EndpointWithMapping<TRequest, TResponse, TEntity> Inherited Members Endpoint<TRequest, TResponse>.HandleAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.ExecuteAsync(TRequest, CancellationToken) Endpoint<TRequest, TResponse>.TryResolve<TService>() Endpoint<TRequest, TResponse>.TryResolve(Type) Endpoint<TRequest, TResponse>.Resolve<TService>() Endpoint<TRequest, TResponse>.Resolve(Type) Endpoint<TRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<TRequest, TResponse>.Route<T>(String, Boolean) Endpoint<TRequest, TResponse>.Query<T>(String, Boolean) Endpoint<TRequest, TResponse>.OnBeforeValidate(TRequest) Endpoint<TRequest, TResponse>.OnBeforeValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidate(TRequest) Endpoint<TRequest, TResponse>.OnAfterValidateAsync(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandle(TRequest) Endpoint<TRequest, TResponse>.OnBeforeHandleAsync(TRequest) Endpoint<TRequest, TResponse>.OnAfterHandle(TRequest, TResponse) Endpoint<TRequest, TResponse>.OnAfterHandleAsync(TRequest, TResponse) Endpoint<TRequest, TResponse>.ValidationFailed Endpoint<TRequest, TResponse>.User Endpoint<TRequest, TResponse>.Response Endpoint<TRequest, TResponse>.Config Endpoint<TRequest, TResponse>.Env Endpoint<TRequest, TResponse>.Logger Endpoint<TRequest, TResponse>.BaseURL Endpoint<TRequest, TResponse>.HttpMethod Endpoint<TRequest, TResponse>.Form Endpoint<TRequest, TResponse>.Files Endpoint<TRequest, TResponse>.ResponseStarted Endpoint<TRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendStringAsync(String, Int32, String, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(TResponse, CancellationToken) Endpoint<TRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendErrorsAsync(Int32, CancellationToken) Endpoint<TRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<TRequest, TResponse>.SendRedirectAsync(String, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<TRequest, TResponse>.SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) Endpoint<TRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<TRequest, TResponse>.Get(String[]) Endpoint<TRequest, TResponse>.Post(String[]) Endpoint<TRequest, TResponse>.Put(String[]) Endpoint<TRequest, TResponse>.Patch(String[]) Endpoint<TRequest, TResponse>.Delete(String[]) Endpoint<TRequest, TResponse>.Routes(String[]) Endpoint<TRequest, TResponse>.Verbs(Http[]) Endpoint<TRequest, TResponse>.DontThrowIfValidationFails() Endpoint<TRequest, TResponse>.DontAutoTag() Endpoint<TRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<TRequest, TResponse>.AllowFileUploads() Endpoint<TRequest, TResponse>.AllowFormData() Endpoint<TRequest, TResponse>.Policies(String[]) Endpoint<TRequest, TResponse>.Roles(String[]) Endpoint<TRequest, TResponse>.Permissions(String[]) Endpoint<TRequest, TResponse>.PermissionsAll(String[]) Endpoint<TRequest, TResponse>.Claims(String[]) Endpoint<TRequest, TResponse>.ClaimsAll(String[]) Endpoint<TRequest, TResponse>.AuthSchemes(String[]) Endpoint<TRequest, TResponse>.PreProcessors(IPreProcessor<TRequest>[]) Endpoint<TRequest, TResponse>.PostProcessors(IPostProcessor<TRequest, TResponse>[]) Endpoint<TRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<TRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<TRequest, TResponse>.Description(Action<RouteHandlerBuilder>, Boolean) Endpoint<TRequest, TResponse>.Summary(Action<EndpointSummary>) Endpoint<TRequest, TResponse>.Summary(Action<EndpointSummary<TRequest>>) Endpoint<TRequest, TResponse>.Summary(EndpointSummary) Endpoint<TRequest, TResponse>.Tags(String[]) Endpoint<TRequest, TResponse>.Version(Int32, Nullable<Int32>) Endpoint<TRequest, TResponse>.Throttle(Int32, Double, String) Endpoint<TRequest, TResponse>.SerializerContext<TContext>(TContext) Endpoint<TRequest, TResponse>.ScopedValidator() Endpoint<TRequest, TResponse>.RoutePrefixOverride(String) Endpoint<TRequest, TResponse>.AddError(String) Endpoint<TRequest, TResponse>.AddError(Expression<Func<TRequest, Object>>, String) Endpoint<TRequest, TResponse>.ThrowIfAnyErrors() Endpoint<TRequest, TResponse>.ThrowError(String) Endpoint<TRequest, TResponse>.ThrowError(Expression<Func<TRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.Verbs(Http[]) BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithMapping<TRequest, TResponse, TEntity> : Endpoint<TRequest, TResponse>, IEndpoint, IServiceResolver where TRequest : new() where TResponse : new() Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto TEntity the type of domain entity that will be mapped to/from Methods MapFromEntity(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual TResponse MapFromEntity(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description TResponse MapFromEntityAsync(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual Task<TResponse> MapFromEntityAsync(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description Task <TResponse> MapToEntity(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual TEntity MapToEntity(TRequest r) Parameters Type Name Description TRequest r the request dto Returns Type Description TEntity MapToEntityAsync(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual Task<TEntity> MapToEntityAsync(TRequest r) Parameters Type Name Description TRequest r the request dto to map from Returns Type Description Task <TEntity>"
  },
  "api/FastEndpoints.EndpointWithoutRequest.html": {
    "href": "api/FastEndpoints.EndpointWithoutRequest.html",
    "title": "Class EndpointWithoutRequest | FastEndpoints",
    "keywords": "Class EndpointWithoutRequest use this base class for defining endpoints that doesn't need a request dto. usually used for routes that doesn't have any parameters. Inheritance System.Object BaseEndpoint Endpoint < EmptyRequest , System.Object > Endpoint < EmptyRequest > EndpointWithoutRequest Inherited Members Endpoint<EmptyRequest, Object>.HandleAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, Object>.ExecuteAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, Object>.TryResolve<TService>() Endpoint<EmptyRequest, Object>.TryResolve(Type) Endpoint<EmptyRequest, Object>.Resolve<TService>() Endpoint<EmptyRequest, Object>.Resolve(Type) Endpoint<EmptyRequest, Object>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<EmptyRequest, Object>.Route<T>(String, Boolean) Endpoint<EmptyRequest, Object>.Query<T>(String, Boolean) Endpoint<EmptyRequest, Object>.OnBeforeValidate(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeValidateAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterValidate(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterValidateAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeHandle(EmptyRequest) Endpoint<EmptyRequest, Object>.OnBeforeHandleAsync(EmptyRequest) Endpoint<EmptyRequest, Object>.OnAfterHandle(EmptyRequest, Object) Endpoint<EmptyRequest, Object>.OnAfterHandleAsync(EmptyRequest, Object) Endpoint<EmptyRequest, Object>.ValidationFailed Endpoint<EmptyRequest, Object>.User Endpoint<EmptyRequest, Object>.Response Endpoint<EmptyRequest, Object>.Config Endpoint<EmptyRequest, Object>.Env Endpoint<EmptyRequest, Object>.Logger Endpoint<EmptyRequest, Object>.BaseURL Endpoint<EmptyRequest, Object>.HttpMethod Endpoint<EmptyRequest, Object>.Form Endpoint<EmptyRequest, Object>.Files Endpoint<EmptyRequest, Object>.ResponseStarted Endpoint<EmptyRequest, Object>.SendAsync(Object, Int32, CancellationToken) Endpoint<EmptyRequest, Object>.SendCreatedAtAsync<TEndpoint>(Object, Object, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendCreatedAtAsync(String, Object, Object, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendStringAsync(String, Int32, String, CancellationToken) Endpoint<EmptyRequest, Object>.SendOkAsync(Object, CancellationToken) Endpoint<EmptyRequest, Object>.SendOkAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendErrorsAsync(Int32, CancellationToken) Endpoint<EmptyRequest, Object>.SendNoContentAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendNotFoundAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendUnauthorizedAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendForbiddenAsync(CancellationToken) Endpoint<EmptyRequest, Object>.SendRedirectAsync(String, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, Object>.SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) Endpoint<EmptyRequest, Object>.SendEmptyJsonObject(CancellationToken) Endpoint<EmptyRequest, Object>.Get(String[]) Endpoint<EmptyRequest, Object>.Post(String[]) Endpoint<EmptyRequest, Object>.Put(String[]) Endpoint<EmptyRequest, Object>.Patch(String[]) Endpoint<EmptyRequest, Object>.Delete(String[]) Endpoint<EmptyRequest, Object>.Routes(String[]) Endpoint<EmptyRequest, Object>.Verbs(Http[]) Endpoint<EmptyRequest, Object>.DontThrowIfValidationFails() Endpoint<EmptyRequest, Object>.DontAutoTag() Endpoint<EmptyRequest, Object>.AllowAnonymous(Http[]) Endpoint<EmptyRequest, Object>.AllowFileUploads() Endpoint<EmptyRequest, Object>.AllowFormData() Endpoint<EmptyRequest, Object>.Policies(String[]) Endpoint<EmptyRequest, Object>.Roles(String[]) Endpoint<EmptyRequest, Object>.Permissions(String[]) Endpoint<EmptyRequest, Object>.PermissionsAll(String[]) Endpoint<EmptyRequest, Object>.Claims(String[]) Endpoint<EmptyRequest, Object>.ClaimsAll(String[]) Endpoint<EmptyRequest, Object>.AuthSchemes(String[]) Endpoint<EmptyRequest, Object>.PreProcessors(IPreProcessor<EmptyRequest>[]) Endpoint<EmptyRequest, Object>.PostProcessors(IPostProcessor<EmptyRequest, Object>[]) Endpoint<EmptyRequest, Object>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<EmptyRequest, Object>.Options(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, Object>.Description(Action<RouteHandlerBuilder>, Boolean) Endpoint<EmptyRequest, Object>.Summary(Action<EndpointSummary>) Endpoint<EmptyRequest, Object>.Summary(Action<EndpointSummary<EmptyRequest>>) Endpoint<EmptyRequest, Object>.Summary(EndpointSummary) Endpoint<EmptyRequest, Object>.Tags(String[]) Endpoint<EmptyRequest, Object>.Version(Int32, Nullable<Int32>) Endpoint<EmptyRequest, Object>.Throttle(Int32, Double, String) Endpoint<EmptyRequest, Object>.SerializerContext<TContext>(TContext) Endpoint<EmptyRequest, Object>.ScopedValidator() Endpoint<EmptyRequest, Object>.RoutePrefixOverride(String) Endpoint<EmptyRequest, Object>.AddError(String) Endpoint<EmptyRequest, Object>.AddError(Expression<Func<EmptyRequest, Object>>, String) Endpoint<EmptyRequest, Object>.ThrowIfAnyErrors() Endpoint<EmptyRequest, Object>.ThrowError(String) Endpoint<EmptyRequest, Object>.ThrowError(Expression<Func<EmptyRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.Verbs(Http[]) BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithoutRequest : Endpoint<EmptyRequest>, IEndpoint, IServiceResolver Methods ExecuteAsync(CancellationToken) the handler method for the endpoint. this method is called for each request received. Declaration public virtual Task<object> ExecuteAsync(CancellationToken ct) Parameters Type Name Description CancellationToken ct a cancellation token Returns Type Description Task < System.Object > ExecuteAsync(EmptyRequest, CancellationToken) override the ExecuteAsync(CancellationToken ct) method instead of using this method! Declaration public sealed override Task<object> ExecuteAsync(EmptyRequest _, CancellationToken ct) Parameters Type Name Description EmptyRequest _ CancellationToken ct Returns Type Description Task < System.Object > Overrides FastEndpoints.Endpoint<FastEndpoints.EmptyRequest, System.Object>.ExecuteAsync(FastEndpoints.EmptyRequest, CancellationToken) HandleAsync(CancellationToken) the handler method for the endpoint. this method is called for each request received. Declaration public virtual Task HandleAsync(CancellationToken ct) Parameters Type Name Description CancellationToken ct a cancellation token Returns Type Description Task HandleAsync(EmptyRequest, CancellationToken) override the HandleAsync(CancellationToken ct) method instead of using this method! Declaration public sealed override Task HandleAsync(EmptyRequest _, CancellationToken ct) Parameters Type Name Description EmptyRequest _ CancellationToken ct Returns Type Description Task Overrides FastEndpoints.Endpoint<FastEndpoints.EmptyRequest, System.Object>.HandleAsync(FastEndpoints.EmptyRequest, CancellationToken)"
  },
  "api/FastEndpoints.EndpointWithoutRequest-1.html": {
    "href": "api/FastEndpoints.EndpointWithoutRequest-1.html",
    "title": "Class EndpointWithoutRequest<TResponse> | FastEndpoints",
    "keywords": "Class EndpointWithoutRequest<TResponse> use this base class for defining endpoints that doesn't need a request dto but return a response dto. Inheritance System.Object BaseEndpoint Endpoint < EmptyRequest , TResponse> EndpointWithoutRequest<TResponse> Inherited Members Endpoint<EmptyRequest, TResponse>.HandleAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, TResponse>.ExecuteAsync(EmptyRequest, CancellationToken) Endpoint<EmptyRequest, TResponse>.TryResolve<TService>() Endpoint<EmptyRequest, TResponse>.TryResolve(Type) Endpoint<EmptyRequest, TResponse>.Resolve<TService>() Endpoint<EmptyRequest, TResponse>.Resolve(Type) Endpoint<EmptyRequest, TResponse>.PublishAsync<TEvent>(TEvent, Mode, CancellationToken) Endpoint<EmptyRequest, TResponse>.Route<T>(String, Boolean) Endpoint<EmptyRequest, TResponse>.Query<T>(String, Boolean) Endpoint<EmptyRequest, TResponse>.OnBeforeValidate(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeValidateAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterValidate(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterValidateAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeHandle(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnBeforeHandleAsync(EmptyRequest) Endpoint<EmptyRequest, TResponse>.OnAfterHandle(EmptyRequest, TResponse) Endpoint<EmptyRequest, TResponse>.OnAfterHandleAsync(EmptyRequest, TResponse) Endpoint<EmptyRequest, TResponse>.ValidationFailed Endpoint<EmptyRequest, TResponse>.User Endpoint<EmptyRequest, TResponse>.Response Endpoint<EmptyRequest, TResponse>.Config Endpoint<EmptyRequest, TResponse>.Env Endpoint<EmptyRequest, TResponse>.Logger Endpoint<EmptyRequest, TResponse>.BaseURL Endpoint<EmptyRequest, TResponse>.HttpMethod Endpoint<EmptyRequest, TResponse>.Form Endpoint<EmptyRequest, TResponse>.Files Endpoint<EmptyRequest, TResponse>.ResponseStarted Endpoint<EmptyRequest, TResponse>.SendAsync(TResponse, Int32, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendCreatedAtAsync<TEndpoint>(Object, TResponse, Nullable<Http>, Nullable<Int32>, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendCreatedAtAsync(String, Object, TResponse, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendStringAsync(String, Int32, String, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendOkAsync(TResponse, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendOkAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendErrorsAsync(Int32, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendNoContentAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendNotFoundAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendUnauthorizedAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendForbiddenAsync(CancellationToken) Endpoint<EmptyRequest, TResponse>.SendRedirectAsync(String, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendBytesAsync(Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendFileAsync(FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendStreamAsync(Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendEventStreamAsync<T>(String, IAsyncEnumerable<T>, CancellationToken) Endpoint<EmptyRequest, TResponse>.SendEmptyJsonObject(CancellationToken) Endpoint<EmptyRequest, TResponse>.Get(String[]) Endpoint<EmptyRequest, TResponse>.Post(String[]) Endpoint<EmptyRequest, TResponse>.Put(String[]) Endpoint<EmptyRequest, TResponse>.Patch(String[]) Endpoint<EmptyRequest, TResponse>.Delete(String[]) Endpoint<EmptyRequest, TResponse>.Routes(String[]) Endpoint<EmptyRequest, TResponse>.Verbs(Http[]) Endpoint<EmptyRequest, TResponse>.DontThrowIfValidationFails() Endpoint<EmptyRequest, TResponse>.DontAutoTag() Endpoint<EmptyRequest, TResponse>.AllowAnonymous(Http[]) Endpoint<EmptyRequest, TResponse>.AllowFileUploads() Endpoint<EmptyRequest, TResponse>.AllowFormData() Endpoint<EmptyRequest, TResponse>.Policies(String[]) Endpoint<EmptyRequest, TResponse>.Roles(String[]) Endpoint<EmptyRequest, TResponse>.Permissions(String[]) Endpoint<EmptyRequest, TResponse>.PermissionsAll(String[]) Endpoint<EmptyRequest, TResponse>.Claims(String[]) Endpoint<EmptyRequest, TResponse>.ClaimsAll(String[]) Endpoint<EmptyRequest, TResponse>.AuthSchemes(String[]) Endpoint<EmptyRequest, TResponse>.PreProcessors(IPreProcessor<EmptyRequest>[]) Endpoint<EmptyRequest, TResponse>.PostProcessors(IPostProcessor<EmptyRequest, TResponse>[]) Endpoint<EmptyRequest, TResponse>.ResponseCache(Int32, ResponseCacheLocation, Boolean, String, String[]) Endpoint<EmptyRequest, TResponse>.Options(Action<RouteHandlerBuilder>) Endpoint<EmptyRequest, TResponse>.Description(Action<RouteHandlerBuilder>, Boolean) Endpoint<EmptyRequest, TResponse>.Summary(Action<EndpointSummary>) Endpoint<EmptyRequest, TResponse>.Summary(Action<EndpointSummary<EmptyRequest>>) Endpoint<EmptyRequest, TResponse>.Summary(EndpointSummary) Endpoint<EmptyRequest, TResponse>.Tags(String[]) Endpoint<EmptyRequest, TResponse>.Version(Int32, Nullable<Int32>) Endpoint<EmptyRequest, TResponse>.Throttle(Int32, Double, String) Endpoint<EmptyRequest, TResponse>.SerializerContext<TContext>(TContext) Endpoint<EmptyRequest, TResponse>.ScopedValidator() Endpoint<EmptyRequest, TResponse>.RoutePrefixOverride(String) Endpoint<EmptyRequest, TResponse>.AddError(String) Endpoint<EmptyRequest, TResponse>.AddError(Expression<Func<EmptyRequest, Object>>, String) Endpoint<EmptyRequest, TResponse>.ThrowIfAnyErrors() Endpoint<EmptyRequest, TResponse>.ThrowError(String) Endpoint<EmptyRequest, TResponse>.ThrowError(Expression<Func<EmptyRequest, Object>>, String) BaseEndpoint._httpContext BaseEndpoint.Configuration BaseEndpoint.Verbs(Http[]) BaseEndpoint.HttpContext BaseEndpoint.ValidationFailures BaseEndpoint.Configure() System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class EndpointWithoutRequest<TResponse> : Endpoint<EmptyRequest, TResponse>, IEndpoint, IServiceResolver where TResponse : new() Type Parameters Name Description TResponse the type of the response dto Methods ExecuteAsync(CancellationToken) the handler method for the endpoint that returns the response dto. this method is called for each request received. Declaration public virtual Task<TResponse> ExecuteAsync(CancellationToken ct) Parameters Type Name Description CancellationToken ct a cancellation token Returns Type Description Task <TResponse> ExecuteAsync(EmptyRequest, CancellationToken) override the ExecuteAsync(CancellationToken ct) method instead of using this method! Declaration public sealed override Task<TResponse> ExecuteAsync(EmptyRequest _, CancellationToken ct) Parameters Type Name Description EmptyRequest _ CancellationToken ct Returns Type Description Task <TResponse> Overrides FastEndpoints.Endpoint<FastEndpoints.EmptyRequest, TResponse>.ExecuteAsync(FastEndpoints.EmptyRequest, CancellationToken) HandleAsync(CancellationToken) the handler method for the endpoint. this method is called for each request received. Declaration public virtual Task HandleAsync(CancellationToken ct) Parameters Type Name Description CancellationToken ct a cancellation token Returns Type Description Task HandleAsync(EmptyRequest, CancellationToken) override the HandleAsync(CancellationToken ct) method instead of using this method! Declaration public sealed override Task HandleAsync(EmptyRequest _, CancellationToken ct) Parameters Type Name Description EmptyRequest _ CancellationToken ct Returns Type Description Task Overrides FastEndpoints.Endpoint<FastEndpoints.EmptyRequest, TResponse>.HandleAsync(FastEndpoints.EmptyRequest, CancellationToken)"
  },
  "api/FastEndpoints.EpVersion.html": {
    "href": "api/FastEndpoints.EpVersion.html",
    "title": "Class EpVersion | FastEndpoints",
    "keywords": "Class EpVersion represents an enpoint version Inheritance System.Object EpVersion Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class EpVersion Properties Current Declaration public int Current { get; } Property Value Type Description System.Int32 DeprecatedAt Declaration public int DeprecatedAt { get; } Property Value Type Description System.Int32"
  },
  "api/FastEndpoints.ErrorResponse.html": {
    "href": "api/FastEndpoints.ErrorResponse.html",
    "title": "Class ErrorResponse | FastEndpoints",
    "keywords": "Class ErrorResponse the dto used to send an error response to the client Inheritance System.Object ErrorResponse Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public sealed class ErrorResponse Constructors ErrorResponse() instantiate a new error response without any errors Declaration public ErrorResponse() ErrorResponse(List<ValidationFailure>, Int32) instantiate an error response with the given collection validation failures Declaration public ErrorResponse(List<ValidationFailure> failures, int statusCode = 400) Parameters Type Name Description List < FluentValidation.Results.ValidationFailure > failures System.Int32 statusCode Properties Errors the collection of errors for the current context Declaration public Dictionary<string, List<string>> Errors { get; set; } Property Value Type Description Dictionary < System.String , List < System.String >> Message the message for the error response Declaration public string Message { get; set; } Property Value Type Description System.String StatusCode the http status code sent to the client. default is 400. Declaration public int StatusCode { get; set; } Property Value Type Description System.Int32"
  },
  "api/FastEndpoints.Event-1.html": {
    "href": "api/FastEndpoints.Event-1.html",
    "title": "Class Event<TEvent> | FastEndpoints",
    "keywords": "Class Event<TEvent> event notification hub which uses an in-process pub/sub messaging system based on .net events Inheritance System.Object Event<TEvent> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class Event<TEvent> Type Parameters Name Description TEvent the type of notification event Methods PublishAsync(TEvent, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public static Task PublishAsync(TEvent eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) Parameters Type Name Description TEvent eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work."
  },
  "api/FastEndpoints.ExceptionHandlerExtensions.html": {
    "href": "api/FastEndpoints.ExceptionHandlerExtensions.html",
    "title": "Class ExceptionHandlerExtensions | FastEndpoints",
    "keywords": "Class ExceptionHandlerExtensions extensions for global exception handling Inheritance System.Object ExceptionHandlerExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class ExceptionHandlerExtensions Methods UseDefaultExceptionHandler(IApplicationBuilder, ILogger) registers the default global exception handler which will log the exceptions on the server and return a user-friendly json response to the client when unhandled exceptions occur. TIP: when using this exception handler, you may want to turn off the asp.net core exception middleware logging to avoid duplication like so: \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\", \"Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\": \"None\" } } Declaration public static void UseDefaultExceptionHandler(this IApplicationBuilder app, ILogger logger = null) Parameters Type Name Description Microsoft.AspNetCore.Builder.IApplicationBuilder app Microsoft.Extensions.Logging.ILogger logger an optional logger instance"
  },
  "api/FastEndpoints.Factory.html": {
    "href": "api/FastEndpoints.Factory.html",
    "title": "Class Factory | FastEndpoints",
    "keywords": "Class Factory a factory for instantiaing endpoints for testing purposes Inheritance System.Object Factory Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class Factory Methods Create<TEndpoint>(Action<DefaultHttpContext>, Object[]) get an instance of an endpoint suitable for unit testing Declaration public static TEndpoint Create<TEndpoint>(Action<DefaultHttpContext> httpContext, params object[] dependancies) where TEndpoint : class, IEndpoint Parameters Type Name Description Action < Microsoft.AspNetCore.Http.DefaultHttpContext > httpContext an action for configuring the default http context object System.Object [] dependancies the dependancies of the endpoint if it has any constructor injected arguments Returns Type Description TEndpoint Type Parameters Name Description TEndpoint the type of the endpoint to create an instance of Create<TEndpoint>(DefaultHttpContext, Object[]) get an instance of an endpoint suitable for unit testing Declaration public static TEndpoint Create<TEndpoint>(DefaultHttpContext httContext, params object[] dependancies) where TEndpoint : class, IEndpoint Parameters Type Name Description Microsoft.AspNetCore.Http.DefaultHttpContext httContext a default http context object System.Object [] dependancies the dependancies of the endpoint if it has injected dependancies Returns Type Description TEndpoint Type Parameters Name Description TEndpoint the type of the endpoint to create an instance of Create<TEndpoint>(Object[]) get an instance of an endpoint suitable for unit testing Declaration public static TEndpoint Create<TEndpoint>(params object[] dependancies) where TEndpoint : class, IEndpoint Parameters Type Name Description System.Object [] dependancies the dependancies of the endpoint if it has any constructor injected arguments Returns Type Description TEndpoint Type Parameters Name Description TEndpoint the type of the endpoint to create an instance of"
  },
  "api/FastEndpoints.FastEventHandler-1.html": {
    "href": "api/FastEndpoints.FastEventHandler-1.html",
    "title": "Class FastEventHandler<TEvent> | FastEndpoints",
    "keywords": "Class FastEventHandler<TEvent> use this base class to handle events published by the notification system Inheritance System.Object FastEventHandler<TEvent> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class FastEventHandler<TEvent> : IEventHandler, IServiceResolver Type Parameters Name Description TEvent the type of the event to handle Methods HandleAsync(TEvent, CancellationToken) this method will be called when an event of the specified type is published. Declaration public abstract Task HandleAsync(TEvent eventModel, CancellationToken ct) Parameters Type Name Description TEvent eventModel the event model/dto received CancellationToken ct an optional cancellation token Returns Type Description Task PublishAsync<TEventModel>(TEventModel, Mode, CancellationToken) publish the given model/dto to all the subscribers of the event notification Declaration public Task PublishAsync<TEventModel>(TEventModel eventModel, Mode waitMode = Mode.WaitForAll, CancellationToken cancellation = null) where TEventModel : class Parameters Type Name Description TEventModel eventModel the notification event model/dto to publish Mode waitMode specify whether to wait for none, any or all of the subscribers to complete their work CancellationToken cancellation an optional cancellation token Returns Type Description Task a Task that matches the wait mode specified. Mode.WaitForNone returns an already completed Task (fire and forget). Mode.WaitForAny returns a Task that will complete when any of the subscribers complete their work. Mode.WaitForAll return a Task that will complete only when all of the subscribers complete their work. Type Parameters Name Description TEventModel Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve"
  },
  "api/FastEndpoints.FromAttribute.html": {
    "href": "api/FastEndpoints.FromAttribute.html",
    "title": "Class FromAttribute | FastEndpoints",
    "keywords": "Class FromAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. Inheritance System.Object FromClaimAttribute FromAttribute Inherited Members FromClaimAttribute.ClaimType FromClaimAttribute.IsRequired Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromAttribute : FromClaimAttribute Constructors FromAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. Declaration public FromAttribute(string claimType, bool isRequired = true) Parameters Type Name Description System.String claimType the claim type to auto bind System.Boolean isRequired set to true if a validation error should be thrown when the current user principal doesn't have the specified claim"
  },
  "api/FastEndpoints.FromClaimAttribute.html": {
    "href": "api/FastEndpoints.FromClaimAttribute.html",
    "title": "Class FromClaimAttribute | FastEndpoints",
    "keywords": "Class FromClaimAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Inheritance System.Object FromClaimAttribute FromAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromClaimAttribute : Attribute Constructors FromClaimAttribute(Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Declaration public FromClaimAttribute(bool isRequired) Parameters Type Name Description System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user principal doesn't have a claim type matching the property name being bound to. FromClaimAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal Declaration public FromClaimAttribute(string claimType = null, bool isRequired = true) Parameters Type Name Description System.String claimType optionally specify the claim type to bind from. if not specified, the claim type of the user principal must match the name of the property being bound to. System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user principal doesn't have the specified claim type Properties ClaimType the claim type to auto bind Declaration public string ClaimType { get; set; } Property Value Type Description System.String IsRequired set to true if a validation error should be thrown when the current user principal doesn't have the specified claim Declaration public bool IsRequired { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FastEndpoints.FromHeaderAttribute.html": {
    "href": "api/FastEndpoints.FromHeaderAttribute.html",
    "title": "Class FromHeaderAttribute | FastEndpoints",
    "keywords": "Class FromHeaderAttribute properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Inheritance System.Object FromHeaderAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class FromHeaderAttribute : Attribute Constructors FromHeaderAttribute(Boolean) properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Declaration public FromHeaderAttribute(bool isRequired) Parameters Type Name Description System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current user request doesn't have a header matching the property name being bound to. FromHeaderAttribute(String, Boolean) properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. Declaration public FromHeaderAttribute(string headerName = null, bool isRequired = true) Parameters Type Name Description System.String headerName optionally specify the header name to bind from. if not specified, the header name must match the name of the property being bound to. System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current request doesn't have the specified header. Properties HeaderName the header name to auto bind from Declaration public string HeaderName { get; set; } Property Value Type Description System.String IsRequired set to true if a validation error should be thrown when the current request doesn't have the specified header Declaration public bool IsRequired { get; set; } Property Value Type Description System.Boolean"
  },
  "api/FastEndpoints.HasPermissionAttribute.html": {
    "href": "api/FastEndpoints.HasPermissionAttribute.html",
    "title": "Class HasPermissionAttribute | FastEndpoints",
    "keywords": "Class HasPermissionAttribute boolean properties decorated with this attribute will have their values set to true if the current principal has the specified permission. Inheritance System.Object HasPermissionAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HasPermissionAttribute : Attribute Constructors HasPermissionAttribute(String, Boolean) boolean properties decorated with this attribute will have their values set to true if the current principal has the specified permission. Declaration public HasPermissionAttribute(string permission, bool isRequired = true) Parameters Type Name Description System.String permission the permission to check for System.Boolean isRequired set to false if a validation error shouldn't be thrown when the current principal doesn't have the specified permission. Properties IsRequired set to true if a validation error should be thrown when the current user principal doesn't have the specified permission Declaration public bool IsRequired { get; set; } Property Value Type Description System.Boolean Permission the permission to check for Declaration public string Permission { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.html": {
    "href": "api/FastEndpoints.html",
    "title": "Namespace FastEndpoints | FastEndpoints",
    "keywords": "Namespace FastEndpoints Classes BaseEndpoint BindFromAttribute use this attribute to specify the name of route param, query param, or form field if it's different from the name of the property being bound to. Config global configuration settings for FastEndpoints Endpoint<TRequest> use this base class for defining endpoints that only use a request dto and don't use a response dto. Endpoint<TRequest, TResponse> use this base class for defining endpoints that use both request and response dtos. Endpoint<TRequest, TResponse, TMapper> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity using a seperate entity mapper. EndpointDefinition represents the configuration settings of an endpoint EndpointSummary a class used for providing a textual description about an endpoint for swagger EndpointSummary<TRequest> EndpointWithMapping<TRequest, TResponse, TEntity> use this base class for defining endpoints that use both request and response dtos as well as require mapping to and from a domain entity. EndpointWithoutRequest use this base class for defining endpoints that doesn't need a request dto. usually used for routes that doesn't have any parameters. EndpointWithoutRequest<TResponse> use this base class for defining endpoints that doesn't need a request dto but return a response dto. EpVersion represents an enpoint version ErrorResponse the dto used to send an error response to the client Event<TEvent> event notification hub which uses an in-process pub/sub messaging system based on .net events ExceptionHandlerExtensions extensions for global exception handling Factory a factory for instantiaing endpoints for testing purposes FastEventHandler<TEvent> use this base class to handle events published by the notification system FromAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal. this is a shorter alias for the [FromClaim] attribute. FromClaimAttribute properties decorated with this attribute will have their values auto bound from the relevant claim of the current user principal FromHeaderAttribute properties decorated with this attribute will have their values auto bound from the relevant http header of the current request. HasPermissionAttribute boolean properties decorated with this attribute will have their values set to true if the current principal has the specified permission. HttpAttribute HttpClientExtensions a set of extensions to the httpclient in order to facilitate route-less integration testing HttpDeleteAttribute use this attribute to specify a DELETE route for an endpoint HttpGetAttribute use this attribute to specify a GET route for an endpoint HttpPatchAttribute use this attribute to specify a PATCH route for an endpoint HttpPostAttribute use this attribute to specify a POST route for an endpoint HttpPutAttribute use this attribute to specify a PUT route for an endpoint HttpResponseExtensions MainExtensions provides extensions to easily bootstrap fastendpoints in the asp.net middleware pipeline Mapper<TRequest, TResponse, TEntity> use this base class to define domain entity mappers for your endpoints. HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers. PlainTextRequest use this dto if you need to model bind the raw content body of an incoming http request or you may implement the IPlainTextRequest interface on your own request dto. QueryParamAttribute properties decorated with this attribute will have a corresponding request parameter added to the swagger schema RoutingOptions routing options for the endpoints Validator<TRequest> inherit from this base class to define your dto validators HINT: validators are registered as singletons. i.e. the same validator instance is used to validate each request for best performance. hance, do not maintain state in your validators. VersioningOptions global endpoint versioning options Structs EmptyRequest a request dto that doesn't have any properties EmptyResponse a response dto that doesn't have any properties Interfaces IEntityMapper marker interface for entity mappers IPlainTextRequest implement this interface on your request dto if you need to model bind the raw content body of an incoming http request IPostProcessor<TRequest, TResponse> interface for defining post-processors to be executed after the main endpoint handler is done IPreProcessor<TRequest> interface for defining pre-processors to be executed before the main endpoint handler is called Enums Http enum for specifying a http verb Mode enum for specifying the waiting mode for event notifications"
  },
  "api/FastEndpoints.Http.html": {
    "href": "api/FastEndpoints.Http.html",
    "title": "Enum Http | FastEndpoints",
    "keywords": "Enum Http enum for specifying a http verb Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public enum Http Fields Name Description DELETE remove a record GET retrieve a record PATCH partially update a record POST create a record PUT replace a record"
  },
  "api/FastEndpoints.HttpAttribute.html": {
    "href": "api/FastEndpoints.HttpAttribute.html",
    "title": "Class HttpAttribute | FastEndpoints",
    "keywords": "Class HttpAttribute Inheritance System.Object HttpAttribute HttpDeleteAttribute HttpGetAttribute HttpPatchAttribute HttpPostAttribute HttpPutAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class HttpAttribute : Attribute Constructors HttpAttribute(Http, String) Declaration protected HttpAttribute(Http verb, string route) Parameters Type Name Description Http verb System.String route"
  },
  "api/FastEndpoints.HttpClientExtensions.html": {
    "href": "api/FastEndpoints.HttpClientExtensions.html",
    "title": "Class HttpClientExtensions | FastEndpoints",
    "keywords": "Class HttpClientExtensions a set of extensions to the httpclient in order to facilitate route-less integration testing Inheritance System.Object HttpClientExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class HttpClientExtensions Methods GETAsync<TEndpoint, TResponse>(HttpClient) make a GET request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto GETAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a GET request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> GETAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto GETAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a GET request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto GETAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a GET request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> GETAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto POSTAsync<TEndpoint, TResponse>(HttpClient) make a POST request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto POSTAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a POST request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> POSTAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto POSTAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a POST request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto POSTAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a POST request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> POSTAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto PUTAsync<TEndpoint, TResponse>(HttpClient) make a PUT request to an endpoint using auto route discovery without a request dto and get back a typed response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TEndpoint, TResponse>(this HttpClient client) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TResponse the type of the response dto PUTAsync<TEndpoint, TRequest>(HttpClient, TRequest) make a PUT request to an endpoint using auto route discovery using a request dto that does not send back a response dto. Declaration public static async Task<HttpResponseMessage?> PUTAsync<TEndpoint, TRequest>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.Nullable < HttpResponseMessage >> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto PUTAsync<TRequest, TResponse>(HttpClient, String, TRequest) make a PUT request using a request dto and get back a response dto. Declaration public static async Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TRequest, TResponse>(this HttpClient client, string requestUri, TRequest request) Parameters Type Name Description HttpClient client System.String requestUri the route url to post to TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TRequest type of the requet dto TResponse type of the response dto PUTAsync<TEndpoint, TRequest, TResponse>(HttpClient, TRequest) make a PUT request to an endpoint using auto route discovery using a request dto and get back a response dto. Declaration public static Task<(HttpResponseMessage? response, TResponse result)> PUTAsync<TEndpoint, TRequest, TResponse>(this HttpClient client, TRequest request) where TEndpoint : BaseEndpoint Parameters Type Name Description HttpClient client TRequest request the request dto Returns Type Description Task < System.ValueTuple < System.Nullable < HttpResponseMessage >, TResponse>> Type Parameters Name Description TEndpoint the type of the endpoint TRequest the type of the request dto TResponse the type of the response dto"
  },
  "api/FastEndpoints.HttpDeleteAttribute.html": {
    "href": "api/FastEndpoints.HttpDeleteAttribute.html",
    "title": "Class HttpDeleteAttribute | FastEndpoints",
    "keywords": "Class HttpDeleteAttribute use this attribute to specify a DELETE route for an endpoint Inheritance System.Object HttpAttribute HttpDeleteAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HttpDeleteAttribute : HttpAttribute Constructors HttpDeleteAttribute(String) use this attribute to specify a DELETE route for an endpoint Declaration public HttpDeleteAttribute(string route) Parameters Type Name Description System.String route the route for the endpoint"
  },
  "api/FastEndpoints.HttpGetAttribute.html": {
    "href": "api/FastEndpoints.HttpGetAttribute.html",
    "title": "Class HttpGetAttribute | FastEndpoints",
    "keywords": "Class HttpGetAttribute use this attribute to specify a GET route for an endpoint Inheritance System.Object HttpAttribute HttpGetAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HttpGetAttribute : HttpAttribute Constructors HttpGetAttribute(String) use this attribute to specify a GET route for an endpoint Declaration public HttpGetAttribute(string route) Parameters Type Name Description System.String route the route for the endpoint"
  },
  "api/FastEndpoints.HttpPatchAttribute.html": {
    "href": "api/FastEndpoints.HttpPatchAttribute.html",
    "title": "Class HttpPatchAttribute | FastEndpoints",
    "keywords": "Class HttpPatchAttribute use this attribute to specify a PATCH route for an endpoint Inheritance System.Object HttpAttribute HttpPatchAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HttpPatchAttribute : HttpAttribute Constructors HttpPatchAttribute(String) use this attribute to specify a PATCH route for an endpoint Declaration public HttpPatchAttribute(string route) Parameters Type Name Description System.String route the route for the endpoint"
  },
  "api/FastEndpoints.HttpPostAttribute.html": {
    "href": "api/FastEndpoints.HttpPostAttribute.html",
    "title": "Class HttpPostAttribute | FastEndpoints",
    "keywords": "Class HttpPostAttribute use this attribute to specify a POST route for an endpoint Inheritance System.Object HttpAttribute HttpPostAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HttpPostAttribute : HttpAttribute Constructors HttpPostAttribute(String) use this attribute to specify a POST route for an endpoint Declaration public HttpPostAttribute(string route) Parameters Type Name Description System.String route the route for the endpoint"
  },
  "api/FastEndpoints.HttpPutAttribute.html": {
    "href": "api/FastEndpoints.HttpPutAttribute.html",
    "title": "Class HttpPutAttribute | FastEndpoints",
    "keywords": "Class HttpPutAttribute use this attribute to specify a PUT route for an endpoint Inheritance System.Object HttpAttribute HttpPutAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class HttpPutAttribute : HttpAttribute Constructors HttpPutAttribute(String) use this attribute to specify a PUT route for an endpoint Declaration public HttpPutAttribute(string route) Parameters Type Name Description System.String route the route for the endpoint"
  },
  "api/FastEndpoints.HttpResponseExtensions.html": {
    "href": "api/FastEndpoints.HttpResponseExtensions.html",
    "title": "Class HttpResponseExtensions | FastEndpoints",
    "keywords": "Class HttpResponseExtensions Inheritance System.Object HttpResponseExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class HttpResponseExtensions Methods SendAsync<TResponse>(HttpResponse, TResponse, Int32, JsonSerializerContext, CancellationToken) send the supplied response dto serialized as json to the client. Declaration public static Task SendAsync<TResponse>(this HttpResponse rsp, TResponse response, int statusCode = 200, JsonSerializerContext jsonSerializerContext = null, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp TResponse response the object to serialize to json System.Int32 statusCode optional custom http status code System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task Type Parameters Name Description TResponse SendBytesAsync(HttpResponse, Byte[], String, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send a byte array to the client Declaration public static async Task SendBytesAsync(this HttpResponse rsp, byte[] bytes, string fileName = null, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.Byte [] bytes the bytes to send System.String fileName System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendCreatedAtAsync(HttpResponse, String, Object, Object, JsonSerializerContext, Boolean, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. WARNING: this method is only supported on single verb/route endpoints. it will not produce a `Location` header if used in a multi verb or multi route endpoint. Declaration public static Task SendCreatedAtAsync(this HttpResponse rsp, string endpointName, object routeValues, object responseBody, JsonSerializerContext jsonSerializerContext = null, bool generateAbsoluteUrl = false, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String endpointName the name of the endpoint to use for link generation (openapi route id) System.Object routeValues a route values object with key/value pairs of route information System.Object responseBody the content to be serialized in the response body System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used System.Boolean generateAbsoluteUrl set to true for generating a absolute url instead of relative url for the location header CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendCreatedAtAsync<TEndpoint>(HttpResponse, Object, Object, Nullable<Http>, Nullable<Int32>, JsonSerializerContext, Boolean, CancellationToken) send a 201 created response with a location header containing where the resource can be retrieved from. HINT: if pointing to an endpoint with multiple verbs, make sure to specify the 'verb' argument and if pointing to a multi route endpoint, specify the 'routeNumber' argument. WARNING: this overload will not add a location header if you've set a custom endpoint name using .WithName() method. use the other overload that accepts a string endpoint name instead. Declaration public static Task SendCreatedAtAsync<TEndpoint>(this HttpResponse rsp, object routeValues, object responseBody, Http? verb = null, int? routeNumber = null, JsonSerializerContext jsonSerializerContext = null, bool generateAbsoluteUrl = false, CancellationToken cancellation = null) where TEndpoint : IEndpoint Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.Object routeValues a route values object with key/value pairs of route information System.Object responseBody the content to be serialized in the response body System.Nullable < Http > verb only useful when pointing to a multi verb endpoint System.Nullable < System.Int32 > routeNumber only useful when pointing to a multi route endpoint System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used System.Boolean generateAbsoluteUrl set to true for generating a absolute url instead of relative url for the location header CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task Type Parameters Name Description TEndpoint the type of the endpoint where the resource can be retrieved from SendEmptyJsonObject(HttpResponse, JsonSerializerContext, CancellationToken) send an empty json object in the body Declaration public static Task SendEmptyJsonObject(this HttpResponse rsp, JsonSerializerContext jsonSerializerContext = null, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendErrorsAsync(HttpResponse, List<ValidationFailure>, Int32, JsonSerializerContext, CancellationToken) send a 400 bad request with error details of the current validation failures Declaration public static Task SendErrorsAsync(this HttpResponse rsp, List<ValidationFailure> failures, int statusCode = 400, JsonSerializerContext jsonSerializerContext = null, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp List < FluentValidation.Results.ValidationFailure > failures the collection of failures System.Int32 statusCode the http status code for the error response System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendEventStreamAsync<T>(HttpResponse, String, IAsyncEnumerable<T>, CancellationToken) start a \"server-sent-events\" data stream for the client asynchronously without blocking any threads Declaration public static async Task SendEventStreamAsync<T>(this HttpResponse rsp, string eventName, IAsyncEnumerable<T> eventStream, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String eventName the name of the event stream IAsyncEnumerable <T> eventStream an IAsyncEnumerable that is the source of the data CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task Type Parameters Name Description T the type of the objects being sent in the event stream SendFileAsync(HttpResponse, FileInfo, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send a file to the client Declaration public static Task SendFileAsync(this HttpResponse rsp, FileInfo fileInfo, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp FileInfo fileInfo System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendForbiddenAsync(HttpResponse, CancellationToken) send a 403 unauthorized response Declaration public static Task SendForbiddenAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendNoContentAsync(HttpResponse, CancellationToken) send a 204 no content response Declaration public static Task SendNoContentAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendNotFoundAsync(HttpResponse, CancellationToken) send a 404 not found response Declaration public static Task SendNotFoundAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendOkAsync(HttpResponse, CancellationToken) send an http 200 ok response without any body Declaration public static Task SendOkAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendOkAsync<TResponse>(HttpResponse, TResponse, JsonSerializerContext, CancellationToken) send an http 200 ok response with the supplied response dto serialized as json to the client. Declaration public static Task SendOkAsync<TResponse>(this HttpResponse rsp, TResponse response, JsonSerializerContext jsonSerializerContext = null, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp TResponse response the object to serialize to json System.Text.Json.Serialization.JsonSerializerContext jsonSerializerContext json serializer context if code generation is used CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task Type Parameters Name Description TResponse SendRedirectAsync(HttpResponse, String, Boolean, CancellationToken) send a 301/302 redirect response Declaration public static Task SendRedirectAsync(this HttpResponse rsp, string location, bool isPermanant, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String location the location to redirect to System.Boolean isPermanant set to true for a 302 redirect. 301 is the default. CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendStreamAsync(HttpResponse, Stream, String, Nullable<Int64>, String, Nullable<DateTimeOffset>, Boolean, CancellationToken) send the contents of a stream to the client Declaration public static async Task SendStreamAsync(this HttpResponse rsp, Stream stream, string fileName = null, long? fileLengthBytes = null, string contentType = \"application/octet-stream\", DateTimeOffset? lastModified = null, bool enableRangeProcessing = false, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp Stream stream the stream to read the data from System.String fileName and optional file name to set in the content-disposition header System.Nullable < System.Int64 > fileLengthBytes optional total size of the file/stream System.String contentType optional content type to set on the http response System.Nullable < DateTimeOffset > lastModified optional last modified date-time-offset for the data stream System.Boolean enableRangeProcessing optional switch for enabling range processing CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendStringAsync(HttpResponse, String, Int32, String, CancellationToken) send the supplied string content to the client. Declaration public static Task SendStringAsync(this HttpResponse rsp, string content, int statusCode = 200, string contentType = \"text/plain\", CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp System.String content the string to write to the response body System.Int32 statusCode optional custom http status code System.String contentType optional content type header value CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task SendUnauthorizedAsync(HttpResponse, CancellationToken) send a 401 unauthorized response Declaration public static Task SendUnauthorizedAsync(this HttpResponse rsp, CancellationToken cancellation = null) Parameters Type Name Description Microsoft.AspNetCore.Http.HttpResponse rsp CancellationToken cancellation optional cancellation token. if not specified, the HttpContext.RequestAborted token is used. Returns Type Description Task"
  },
  "api/FastEndpoints.IEntityMapper.html": {
    "href": "api/FastEndpoints.IEntityMapper.html",
    "title": "Interface IEntityMapper | FastEndpoints",
    "keywords": "Interface IEntityMapper marker interface for entity mappers Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IEntityMapper"
  },
  "api/FastEndpoints.IPlainTextRequest.html": {
    "href": "api/FastEndpoints.IPlainTextRequest.html",
    "title": "Interface IPlainTextRequest | FastEndpoints",
    "keywords": "Interface IPlainTextRequest implement this interface on your request dto if you need to model bind the raw content body of an incoming http request Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPlainTextRequest Properties Content the request body content will be bound to this property Declaration string Content { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.IPostProcessor-2.html": {
    "href": "api/FastEndpoints.IPostProcessor-2.html",
    "title": "Interface IPostProcessor<TRequest, TResponse> | FastEndpoints",
    "keywords": "Interface IPostProcessor<TRequest, TResponse> interface for defining post-processors to be executed after the main endpoint handler is done Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPostProcessor<TRequest, TResponse> Type Parameters Name Description TRequest the type of the request dto TResponse the type of the response dto Methods PostProcessAsync(TRequest, TResponse, HttpContext, IReadOnlyCollection<ValidationFailure>, CancellationToken) Declaration Task PostProcessAsync(TRequest req, TResponse res, HttpContext ctx, IReadOnlyCollection<ValidationFailure> failures, CancellationToken ct) Parameters Type Name Description TRequest req TResponse res Microsoft.AspNetCore.Http.HttpContext ctx IReadOnlyCollection < FluentValidation.Results.ValidationFailure > failures CancellationToken ct Returns Type Description Task"
  },
  "api/FastEndpoints.IPreProcessor-1.html": {
    "href": "api/FastEndpoints.IPreProcessor-1.html",
    "title": "Interface IPreProcessor<TRequest> | FastEndpoints",
    "keywords": "Interface IPreProcessor<TRequest> interface for defining pre-processors to be executed before the main endpoint handler is called Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public interface IPreProcessor<TRequest> Type Parameters Name Description TRequest the type of the request dto Methods PreProcessAsync(TRequest, HttpContext, List<ValidationFailure>, CancellationToken) Declaration Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) Parameters Type Name Description TRequest req Microsoft.AspNetCore.Http.HttpContext ctx List < FluentValidation.Results.ValidationFailure > failures CancellationToken ct Returns Type Description Task"
  },
  "api/FastEndpoints.MainExtensions.html": {
    "href": "api/FastEndpoints.MainExtensions.html",
    "title": "Class MainExtensions | FastEndpoints",
    "keywords": "Class MainExtensions provides extensions to easily bootstrap fastendpoints in the asp.net middleware pipeline Inheritance System.Object MainExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public static class MainExtensions Methods AddFastEndpoints(IServiceCollection, Nullable<IEnumerable<Assembly>>) adds the FastEndpoints services to the ASP.Net middleware pipeline Declaration public static IServiceCollection AddFastEndpoints(this IServiceCollection services, IEnumerable<Assembly>? endpointAssmeblies = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.Nullable < IEnumerable < System.Reflection.Assembly >> endpointAssmeblies an optional collection of additional assemblies to discover endpoints from Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection MapFastEndpoints(IEndpointRouteBuilder, Nullable<Action<Config>>) Declaration public static IEndpointRouteBuilder MapFastEndpoints(this IEndpointRouteBuilder app, Action<Config>? configAction = null) Parameters Type Name Description Microsoft.AspNetCore.Routing.IEndpointRouteBuilder app System.Nullable < Action < Config >> configAction Returns Type Description Microsoft.AspNetCore.Routing.IEndpointRouteBuilder UseFastEndpoints(WebApplication, Nullable<Action<Config>>) finalizes auto discovery of endpoints and prepares FastEndpoints to start processing requests HINT: this is the combination of app.UseFastEndpointsMiddleware() and app.MapFastEndpoints() . you can use those two methods separately if you have some special requirement such as using \"Startup.cs\", etc. Declaration public static WebApplication UseFastEndpoints(this WebApplication app, Action<Config>? configAction = null) Parameters Type Name Description Microsoft.AspNetCore.Builder.WebApplication app System.Nullable < Action < Config >> configAction an optional action to configure FastEndpoints Returns Type Description Microsoft.AspNetCore.Builder.WebApplication UseFastEndpointsMiddleware(IApplicationBuilder) Declaration public static IApplicationBuilder UseFastEndpointsMiddleware(this IApplicationBuilder app) Parameters Type Name Description Microsoft.AspNetCore.Builder.IApplicationBuilder app Returns Type Description Microsoft.AspNetCore.Builder.IApplicationBuilder"
  },
  "api/FastEndpoints.Mapper-3.html": {
    "href": "api/FastEndpoints.Mapper-3.html",
    "title": "Class Mapper<TRequest, TResponse, TEntity> | FastEndpoints",
    "keywords": "Class Mapper<TRequest, TResponse, TEntity> use this base class to define domain entity mappers for your endpoints. HINT: entity mappers are used as singletons for performance reasons. do not maintain state in the mappers. Inheritance System.Object Mapper<TRequest, TResponse, TEntity> Implements IEntityMapper Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Mapper<TRequest, TResponse, TEntity> : IEntityMapper, IServiceResolver where TRequest : new() where TResponse : new() Type Parameters Name Description TRequest the type of request dto TResponse the type of response dto TEntity the type of domain entity to map to/from Methods FromEntity(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual TResponse FromEntity(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description TResponse FromEntityAsync(TEntity) override this method and place the logic for mapping a domain entity to a response dto Declaration public virtual Task<TResponse> FromEntityAsync(TEntity e) Parameters Type Name Description TEntity e the domain entity to map from Returns Type Description Task <TResponse> Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve ToEntity(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual TEntity ToEntity(TRequest r) Parameters Type Name Description TRequest r the request dto Returns Type Description TEntity ToEntityAsync(TRequest) override this method and place the logic for mapping the request dto to the desired domain entity Declaration public virtual Task<TEntity> ToEntityAsync(TRequest r) Parameters Type Name Description TRequest r the request dto to map from Returns Type Description Task <TEntity> TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Implements IEntityMapper"
  },
  "api/FastEndpoints.Mode.html": {
    "href": "api/FastEndpoints.Mode.html",
    "title": "Enum Mode | FastEndpoints",
    "keywords": "Enum Mode enum for specifying the waiting mode for event notifications Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public enum Mode Fields Name Description WaitForAll return a Task that will complete only when all of the subscribers complete their work WaitForAny returns a Task that will complete when any of the subscribers complete their work WaitForNone returns an already completed Task (fire and forget)"
  },
  "api/FastEndpoints.PlainTextRequest.html": {
    "href": "api/FastEndpoints.PlainTextRequest.html",
    "title": "Class PlainTextRequest | FastEndpoints",
    "keywords": "Class PlainTextRequest use this dto if you need to model bind the raw content body of an incoming http request or you may implement the IPlainTextRequest interface on your own request dto. Inheritance System.Object PlainTextRequest Implements IPlainTextRequest Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class PlainTextRequest : IPlainTextRequest Properties Content the body content of the incoming request Declaration public string Content { get; set; } Property Value Type Description System.String Implements IPlainTextRequest"
  },
  "api/FastEndpoints.QueryParamAttribute.html": {
    "href": "api/FastEndpoints.QueryParamAttribute.html",
    "title": "Class QueryParamAttribute | FastEndpoints",
    "keywords": "Class QueryParamAttribute properties decorated with this attribute will have a corresponding request parameter added to the swagger schema Inheritance System.Object QueryParamAttribute Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class QueryParamAttribute : Attribute"
  },
  "api/FastEndpoints.RoutingOptions.html": {
    "href": "api/FastEndpoints.RoutingOptions.html",
    "title": "Class RoutingOptions | FastEndpoints",
    "keywords": "Class RoutingOptions routing options for the endpoints Inheritance System.Object RoutingOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class RoutingOptions Properties Prefix prefix for all routes (example 'api'). Declaration public string Prefix { get; set; } Property Value Type Description System.String"
  },
  "api/FastEndpoints.Security.AuthExtensions.html": {
    "href": "api/FastEndpoints.Security.AuthExtensions.html",
    "title": "Class AuthExtensions | FastEndpoints",
    "keywords": "Class AuthExtensions a set of auth related extensions Inheritance System.Object AuthExtensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public static class AuthExtensions Methods AddAuthenticationJWTBearer(IServiceCollection, String, String, String) configure and enable jwt bearer authentication Declaration public static IServiceCollection AddAuthenticationJWTBearer(this IServiceCollection services, string tokenSigningKey, string issuer = null, string audience = null) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.String tokenSigningKey the secret key to use for verifying the jwt tokens System.String issuer validates issuer if set System.String audience validates audience if set Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection ClaimValue(ClaimsPrincipal, String) get the claim value for a given claim type of the current user principal. if the user doesn't have the requested claim type, a null will be returned. Declaration public static string ClaimValue(this ClaimsPrincipal principal, string claimType) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String claimType the claim type to look for Returns Type Description System.String HasClaimType(ClaimsPrincipal, String) determines if the current user principal has the given claim type Declaration public static bool HasClaimType(this ClaimsPrincipal principal, string claimType) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String claimType the claim type to check for Returns Type Description System.Boolean HasPermission(ClaimsPrincipal, String) returns true of the current user principal has a given permission code. Declaration public static bool HasPermission(this ClaimsPrincipal principal, string permissionCode) Parameters Type Name Description System.Security.Claims.ClaimsPrincipal principal System.String permissionCode the permission code to check for Returns Type Description System.Boolean"
  },
  "api/FastEndpoints.Security.html": {
    "href": "api/FastEndpoints.Security.html",
    "title": "Namespace FastEndpoints.Security | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Security Classes AuthExtensions a set of auth related extensions JWTBearer static class for easy creation of jwt bearer auth tokens Permissions inherit from this class and define your applications permissions as public const string public const string Inventory_Create_Item = \"100\"; public const string Inventory_Retrieve_Item = \"101\"; public const string Inventory_Update_Item = \"102\"; public const string Inventory_Delete_Item = \"103\";"
  },
  "api/FastEndpoints.Security.JWTBearer.html": {
    "href": "api/FastEndpoints.Security.JWTBearer.html",
    "title": "Class JWTBearer | FastEndpoints",
    "keywords": "Class JWTBearer static class for easy creation of jwt bearer auth tokens Inheritance System.Object JWTBearer Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public static class JWTBearer Methods CreateToken(String, Nullable<DateTime>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<Claim>>, String, String) generate a jwt token with the supplied parameters Declaration public static string CreateToken(string signingKey, DateTime? expireAt = null, IEnumerable<string>? permissions = null, IEnumerable<string>? roles = null, IEnumerable<Claim>? claims = null, string issuer = null, string audience = null) Parameters Type Name Description System.String signingKey the secret key to use for signing the tokens System.Nullable < DateTime > expireAt the expiry date System.Nullable < IEnumerable < System.String >> permissions one or more permissions to assign to the user principal System.Nullable < IEnumerable < System.String >> roles one or more roles to assign the user principal System.Nullable < IEnumerable < System.Security.Claims.Claim >> claims one or more claims to assign to the user principal System.String issuer the issuer System.String audience the audience Returns Type Description System.String CreateToken(String, Nullable<DateTime>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, (String claimType, String claimValue)[]) generate a jwt token with the supplied parameters Declaration public static string CreateToken(string signingKey, DateTime? expireAt = null, IEnumerable<string>? permissions = null, IEnumerable<string>? roles = null, params (string claimType, string claimValue)[] claims) Parameters Type Name Description System.String signingKey the secret key to use for signing the tokens System.Nullable < DateTime > expireAt the expiry date System.Nullable < IEnumerable < System.String >> permissions one or more permissions to assign to the user principal System.Nullable < IEnumerable < System.String >> roles one or more roles to assign the user principal System.ValueTuple < System.String , System.String >[] claims one or more claims to assign to the user principal Returns Type Description System.String CreateToken(String, String, String, Nullable<DateTime>, Nullable<IEnumerable<String>>, Nullable<IEnumerable<String>>, (String claimType, String claimValue)[]) generate a jwt token with the supplied parameters Declaration public static string CreateToken(string signingKey, string issuer, string audience, DateTime? expireAt = null, IEnumerable<string>? permissions = null, IEnumerable<string>? roles = null, params (string claimType, string claimValue)[] claims) Parameters Type Name Description System.String signingKey the secret key to use for signing the tokens System.String issuer the issue System.String audience the audience System.Nullable < DateTime > expireAt the expiry date System.Nullable < IEnumerable < System.String >> permissions one or more permissions to assign to the user principal System.Nullable < IEnumerable < System.String >> roles one or more roles to assign the user principal System.ValueTuple < System.String , System.String >[] claims one or more claims to assign to the user principal Returns Type Description System.String"
  },
  "api/FastEndpoints.Security.Permissions.html": {
    "href": "api/FastEndpoints.Security.Permissions.html",
    "title": "Class Permissions | FastEndpoints",
    "keywords": "Class Permissions inherit from this class and define your applications permissions as public const string public const string Inventory_Create_Item = \"100\"; public const string Inventory_Retrieve_Item = \"101\"; public const string Inventory_Update_Item = \"102\"; public const string Inventory_Delete_Item = \"103\"; Inheritance System.Object Permissions Implements System.Collections.IEnumerable < System.ValueTuple < System.String , System.String >> Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Security Assembly : FastEndpoints.Security.dll Syntax public abstract class Permissions : IEnumerable<(string PermissionName, string PermissionCode)> Constructors Permissions() Declaration protected Permissions() Methods AllCodes() get a list of all permission codes Declaration public IEnumerable<string> AllCodes() Returns Type Description System.Collections.IEnumerable < System.String > AllNames() get a list of all permission names Declaration public IEnumerable<string> AllNames() Returns Type Description System.Collections.IEnumerable < System.String > CodesFor(IEnumerable<String>) get a list of permission codes for a given list of permission names Declaration public IEnumerable<string> CodesFor(IEnumerable<string> names) Parameters Type Name Description System.Collections.IEnumerable < System.String > names the permission names to get the codes for Returns Type Description System.Collections.IEnumerable < System.String > GetEnumerator() Declaration public IEnumerator<(string PermissionName, string PermissionCode)> GetEnumerator() Returns Type Description System.Collections.IEnumerator < System.ValueTuple < System.String , System.String >> NamesFor(IEnumerable<String>) gets a list of permission names for the given list of permission codes Declaration public IEnumerable<string> NamesFor(IEnumerable<string> codes) Parameters Type Name Description System.Collections.IEnumerable < System.String > codes the permission codes to get the permission names for Returns Type Description System.Collections.IEnumerable < System.String > PermissionFromCode(String) get the permission tuple using it's code. returns null if not found Declaration public (string PermissionName, string PermissionCode)? PermissionFromCode(string permissionCode) Parameters Type Name Description System.String permissionCode code of the permission to get Returns Type Description System.Nullable < System.ValueTuple < System.String , System.String >> PermissionFromName(String) get the permission tuple using it's name. returns null if not found Declaration public (string PermissionName, string PermissionCode)? PermissionFromName(string permissionName) Parameters Type Name Description System.String permissionName name of the permission Returns Type Description System.Nullable < System.ValueTuple < System.String , System.String >> Explicit Interface Implementations IEnumerable.GetEnumerator() Declaration IEnumerator IEnumerable.GetEnumerator() Returns Type Description System.Collections.IEnumerator Implements System.Collections.IEnumerable<>"
  },
  "api/FastEndpoints.Swagger.Extensions.html": {
    "href": "api/FastEndpoints.Swagger.Extensions.html",
    "title": "Class Extensions | FastEndpoints",
    "keywords": "Class Extensions a set of extension methods for adding swagger support Inheritance System.Object Extensions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints.Swagger Assembly : FastEndpoints.Swagger.dll Syntax public static class Extensions Methods AddAuth(OpenApiDocumentGeneratorSettings, String, OpenApiSecurityScheme, Nullable<IEnumerable<String>>) add swagger auth for this open api document Declaration public static OpenApiDocumentGeneratorSettings AddAuth(this OpenApiDocumentGeneratorSettings s, string schemeName, OpenApiSecurityScheme securityScheme, IEnumerable<string>? globalScopeNames = null) Parameters Type Name Description NSwag.Generation.OpenApiDocumentGeneratorSettings s System.String schemeName the authentication scheme NSwag.OpenApiSecurityScheme securityScheme an open api security scheme object System.Nullable < IEnumerable < System.String >> globalScopeNames a collection of global scope names Returns Type Description NSwag.Generation.OpenApiDocumentGeneratorSettings AddSwaggerDoc(IServiceCollection, Nullable<Action<AspNetCoreOpenApiDocumentGeneratorSettings>>, Nullable<Action<JsonSerializerOptions>>, Boolean, Int32, Int32, Boolean) enable swagger support for FastEndpoints with a single call. Declaration public static IServiceCollection AddSwaggerDoc(this IServiceCollection services, Action<AspNetCoreOpenApiDocumentGeneratorSettings>? settings = null, Action<JsonSerializerOptions>? serializerSettings = null, bool addJWTBearerAuth = true, int tagIndex = 1, int maxEndpointVersion = 0, bool shortSchemaNames = false) Parameters Type Name Description Microsoft.Extensions.DependencyInjection.IServiceCollection services System.Nullable < Action < NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings >> settings swaggergen config settings System.Nullable < Action < System.Text.Json.JsonSerializerOptions >> serializerSettings json serializer options System.Boolean addJWTBearerAuth set to false to disable auto addition of jwt bearer auth support System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints System.Int32 maxEndpointVersion endpoints greater than this version will not be included in the swagger doc System.Boolean shortSchemaNames set to true if you'd like schema names to be the class name intead of the full name Returns Type Description Microsoft.Extensions.DependencyInjection.IServiceCollection ConfigureDefaults(SwaggerUi3Settings, Nullable<Action<SwaggerUi3Settings>>) configure swagger ui with some sensible defaults for FastEndpoints which can be overridden if needed. Declaration public static void ConfigureDefaults(this SwaggerUi3Settings s, Action<SwaggerUi3Settings>? settings = null) Parameters Type Name Description NSwag.AspNetCore.SwaggerUi3Settings s System.Nullable < Action < NSwag.AspNetCore.SwaggerUi3Settings >> settings provide an action that overrides any of the defaults EnableFastEndpoints(AspNetCoreOpenApiDocumentGeneratorSettings, Int32, Int32, Boolean) enable support for FastEndpoints in swagger Declaration public static void EnableFastEndpoints(this AspNetCoreOpenApiDocumentGeneratorSettings settings, int tagIndex, int maxEndpointVersion, bool shortSchemaNames) Parameters Type Name Description NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings settings System.Int32 tagIndex the index of the route path segment to use for tagging/grouping endpoints System.Int32 maxEndpointVersion endpoints greater than this version will not be included in the swagger doc System.Boolean shortSchemaNames set to true to make schema names just the name of the class instead of full type name EnableJWTBearerAuth(AspNetCoreOpenApiDocumentGeneratorSettings) enable jwt bearer authorization support Declaration public static void EnableJWTBearerAuth(this AspNetCoreOpenApiDocumentGeneratorSettings settings) Parameters Type Name Description NSwag.Generation.AspNetCore.AspNetCoreOpenApiDocumentGeneratorSettings settings"
  },
  "api/FastEndpoints.Swagger.html": {
    "href": "api/FastEndpoints.Swagger.html",
    "title": "Namespace FastEndpoints.Swagger | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Swagger Classes Extensions a set of extension methods for adding swagger support"
  },
  "api/FastEndpoints.Validation.html": {
    "href": "api/FastEndpoints.Validation.html",
    "title": "Namespace FastEndpoints.Validation | FastEndpoints",
    "keywords": "Namespace FastEndpoints.Validation Classes ValidationFailureException the exception thrown when a validation error has occured. this class is only useful in unit tests."
  },
  "api/FastEndpoints.Validation.ValidationFailureException.html": {
    "href": "api/FastEndpoints.Validation.ValidationFailureException.html",
    "title": "Class ValidationFailureException | FastEndpoints",
    "keywords": "Class ValidationFailureException the exception thrown when a validation error has occured. this class is only useful in unit tests. Inheritance System.Object ValidationFailureException Namespace : FastEndpoints.Validation Assembly : FastEndpoints.dll Syntax public class ValidationFailureException : Exception Constructors ValidationFailureException() Declaration public ValidationFailureException() ValidationFailureException(String) Declaration public ValidationFailureException(string message) Parameters Type Name Description System.String message ValidationFailureException(String, Nullable<Exception>) Declaration public ValidationFailureException(string message, Exception? innerException) Parameters Type Name Description System.String message System.Nullable < Exception > innerException"
  },
  "api/FastEndpoints.Validator-1.html": {
    "href": "api/FastEndpoints.Validator-1.html",
    "title": "Class Validator<TRequest> | FastEndpoints",
    "keywords": "Class Validator<TRequest> inherit from this base class to define your dto validators HINT: validators are registered as singletons. i.e. the same validator instance is used to validate each request for best performance. hance, do not maintain state in your validators. Inheritance System.Object FluentValidation.AbstractValidator <TRequest> Validator<TRequest> Implements FluentValidation.IValidator <TRequest> FluentValidation.IValidator System.Collections.Generic.IEnumerable < FluentValidation.IValidationRule > System.Collections.IEnumerable Inherited Members FluentValidation.AbstractValidator<TRequest>.FluentValidation.IValidator.Validate(FluentValidation.IValidationContext) FluentValidation.AbstractValidator<TRequest>.FluentValidation.IValidator.ValidateAsync(FluentValidation.IValidationContext, System.Threading.CancellationToken) FluentValidation.AbstractValidator<TRequest>.Validate(TRequest) FluentValidation.AbstractValidator<TRequest>.ValidateAsync(TRequest, System.Threading.CancellationToken) FluentValidation.AbstractValidator<TRequest>.Validate(FluentValidation.ValidationContext<TRequest>) FluentValidation.AbstractValidator<TRequest>.ValidateAsync(FluentValidation.ValidationContext<TRequest>, System.Threading.CancellationToken) FluentValidation.AbstractValidator<TRequest>.CreateDescriptor() FluentValidation.AbstractValidator<TRequest>.FluentValidation.IValidator.CanValidateInstancesOfType(System.Type) FluentValidation.AbstractValidator<TRequest>.RuleFor<TProperty>(System.Linq.Expressions.Expression<System.Func<TRequest, TProperty>>) FluentValidation.AbstractValidator<TRequest>.Transform<TProperty, TTransformed>(System.Linq.Expressions.Expression<System.Func<TRequest, TProperty>>, System.Func<TProperty, TTransformed>) FluentValidation.AbstractValidator<TRequest>.Transform<TProperty, TTransformed>(System.Linq.Expressions.Expression<System.Func<TRequest, TProperty>>, System.Func<TRequest, TProperty, TTransformed>) FluentValidation.AbstractValidator<TRequest>.RuleForEach<TElement>(System.Linq.Expressions.Expression<System.Func<TRequest, System.Collections.Generic.IEnumerable<TElement>>>) FluentValidation.AbstractValidator<TRequest>.TransformForEach<TElement, TTransformed>(System.Linq.Expressions.Expression<System.Func<TRequest, System.Collections.Generic.IEnumerable<TElement>>>, System.Func<TElement, TTransformed>) FluentValidation.AbstractValidator<TRequest>.TransformForEach<TElement, TTransformed>(System.Linq.Expressions.Expression<System.Func<TRequest, System.Collections.Generic.IEnumerable<TElement>>>, System.Func<TRequest, TElement, TTransformed>) FluentValidation.AbstractValidator<TRequest>.RuleSet(System.String, System.Action) FluentValidation.AbstractValidator<TRequest>.When(System.Func<TRequest, System.Boolean>, System.Action) FluentValidation.AbstractValidator<TRequest>.When(System.Func<TRequest, FluentValidation.ValidationContext<TRequest>, System.Boolean>, System.Action) FluentValidation.AbstractValidator<TRequest>.Unless(System.Func<TRequest, System.Boolean>, System.Action) FluentValidation.AbstractValidator<TRequest>.Unless(System.Func<TRequest, FluentValidation.ValidationContext<TRequest>, System.Boolean>, System.Action) FluentValidation.AbstractValidator<TRequest>.WhenAsync(System.Func<TRequest, System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Boolean>>, System.Action) FluentValidation.AbstractValidator<TRequest>.WhenAsync(System.Func<TRequest, FluentValidation.ValidationContext<TRequest>, System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Boolean>>, System.Action) FluentValidation.AbstractValidator<TRequest>.UnlessAsync(System.Func<TRequest, System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Boolean>>, System.Action) FluentValidation.AbstractValidator<TRequest>.UnlessAsync(System.Func<TRequest, FluentValidation.ValidationContext<TRequest>, System.Threading.CancellationToken, System.Threading.Tasks.Task<System.Boolean>>, System.Action) FluentValidation.AbstractValidator<TRequest>.Include(FluentValidation.IValidator<TRequest>) FluentValidation.AbstractValidator<TRequest>.Include<TValidator>(System.Func<TRequest, TValidator>) FluentValidation.AbstractValidator<TRequest>.GetEnumerator() FluentValidation.AbstractValidator<TRequest>.System.Collections.IEnumerable.GetEnumerator() FluentValidation.AbstractValidator<TRequest>.EnsureInstanceNotNull(System.Object) FluentValidation.AbstractValidator<TRequest>.PreValidate(FluentValidation.ValidationContext<TRequest>, FluentValidation.Results.ValidationResult) FluentValidation.AbstractValidator<TRequest>.RaiseValidationException(FluentValidation.ValidationContext<TRequest>, FluentValidation.Results.ValidationResult) FluentValidation.AbstractValidator<TRequest>.CascadeMode System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public abstract class Validator<TRequest> : AbstractValidator<TRequest>, IValidator<TRequest>, IValidator, IEnumerable<IValidationRule>, IEnumerable, IServiceResolver where TRequest : class Type Parameters Name Description TRequest the type of the request dto Methods Resolve(Type) resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public object Resolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object Resolve<TService>() resolve an instance for the given type from the dependency injection container. will throw if unresolvable. Declaration public TService Resolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve TryResolve(Type) try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public object TryResolve(Type typeOfService) Parameters Type Name Description Type typeOfService the type of the service to resolve Returns Type Description System.Object TryResolve<TService>() try to resolve an instance for the given type from the dependency injection container. will return null if unresolvable. Declaration public TService TryResolve<TService>() where TService : class Returns Type Description TService Type Parameters Name Description TService the type of the service to resolve Implements FluentValidation.IValidator<T> FluentValidation.IValidator System.Collections.Generic.IEnumerable<T> System.Collections.IEnumerable"
  },
  "api/FastEndpoints.VersioningOptions.html": {
    "href": "api/FastEndpoints.VersioningOptions.html",
    "title": "Class VersioningOptions | FastEndpoints",
    "keywords": "Class VersioningOptions global endpoint versioning options Inheritance System.Object VersioningOptions Inherited Members System.Object.Equals(System.Object) System.Object.Equals(System.Object, System.Object) System.Object.GetHashCode() System.Object.GetType() System.Object.MemberwiseClone() System.Object.ReferenceEquals(System.Object, System.Object) System.Object.ToString() Namespace : FastEndpoints Assembly : FastEndpoints.dll Syntax public class VersioningOptions Properties DefaultVersion this value will be used on endpoints that does not specify a version Declaration public int DefaultVersion { get; set; } Property Value Type Description System.Int32 Prefix the prefix used in front of the version (for example 'v' produces 'v{version}'). Declaration public string Prefix { get; set; } Property Value Type Description System.String SuffixedVersion set to false if you'd like to prefix the version to the route instead of being suffixed Declaration public bool SuffixedVersion { get; set; } Property Value Type Description System.Boolean"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome | FastEndpoints",
    "keywords": "A light-weight REST Api framework for ASP.Net 6 that implements REPR (Request-Endpoint-Response) Pattern . FastEndpoints offers a better alternative than the Minimal Api and MVC Controllers with the aim of increasing developer productivity. Performance is on par with the Minimal Api and is faster; uses less memory; and does around 45k more requests per second than a MVC Controller in a head-to-head comparison. Features Define endpoints in multiple class files (even in deeply nested folders) Auto discovery & registration of endpoints Attribute-free endpoint definitions (no attribute argument type restrictions) Secure by default & supports most auth providers Built-in support for JWT Bearer auth scheme Supports policy/permission/role/claim based security Declarative security policy building (in each endpoint) Supports any IOC container compatible with asp.net Constructor & property injection of endpoint dependencies Easy model binding from route/query/json body/claims/forms/headers Json source generator support for request/response dtos Easy file handling (multipart/form-data) Model validation with FluentValidation rules Convenient business logic validation & error responses Easy access to environment & configuration settings API versioning Rate limiting Response caching In-process pub/sub event notifications (with auto discovery) Easy Server-Sent-Events real-time data streaming Convenient integration testing (route-less & strongly-typed) Built-in uncaught exception handler Supports swagger/serilog/etc. Visual studio extension (vsix) for easy vertical slice feature scaffolding Plays well with the asp.net middleware pipeline Plus anything else the Minimal APIs can do... Tutorial Documentation Benchmarks"
  },
  "wiki/Api-Versioning.html": {
    "href": "wiki/Api-Versioning.html",
    "title": "api versioning | FastEndpoints",
    "keywords": "api versioning the versioning strategy in FastEndpoints is simplified to require way less effort by the developer. basically, you evolve/version each endpoint in your project independently and group them into a release number/name using swagger. when it's time for an endpoint contract to change, simply leave the existing endpoint alone and create (either by inheriting the old one) or creating a brand new endpoint class and call the Version(x) method in the configuration to indicate that this is the latest incarnation of the endpoint. for example, let's assume the following: initial state your app has the following endpoints - /admin/login - /inventory/order/{OrderID} after evolving an endpoint - /admin/login - /admin/login/v1 - /inventory/order/{OrderID} at this point you can have 2 releases (swagger documents) that look like the following: - initial release |- /admin/login |- /inventory/order/{OrderID} - release 1.0 |- /admin/login/v1 |- /inventory/order/{OrderID} after another change - /admin/login - /admin/login/v1 - /admin/login/v2 - /inventory/order/{OrderID} - /inventory/order/{OrderID}/v1 your releases can now look like this: - initial release |- /admin/login |- /inventory/order/{OrderID} - release 1.0 |- /admin/login/v1 |- /inventory/order/{OrderID} - release 2.0 |- /admin/login/v2 |- /inventory/order/{OrderID}/v1 a release group contains only the latest iteration of each endpoint in your project. all older/previous iterations will not show up. how to define release groups is described below. enable versioning simply specify one of the VersioningOptions settings in startup config in order to activate versioning. app.UseFastEndpoints(c => { c.VersioningOptions = o => o.Prefix = \"v\"; }); define swagger docs (release groups) builder.Services .AddSwaggerDoc(s => { s.DocumentName = \"Initial Release\"; s.Title = \"my api\"; s.Version = \"v1.0\"; }) .AddSwaggerDoc(maxEndpointVersion: 1, settings: s => { s.DocumentName = \"Release 1.0\"; s.Title = \"my api\"; s.Version = \"v1.0\"; }) .AddSwaggerDoc(maxEndpointVersion: 2, settings: s => { s.DocumentName = \"Release 2.0\"; s.Title = \"my api\"; s.Version = \"v2.0\"; }); the thing to note here is the maxEndpointVersion parameter. this is where you specify the max version of an endpoint which a release group should include. any endpoint versions that are greater than this number will not be included in that release group/swagger doc. if you don't specify this, only the initial version of each endpoint will be listed in the group. mark endpoint with a version public class AdminLoginEndpoint_V2 : Endpoint<Request> { public override void Configure() { Get(\"admin/login\"); Version(2); } } deprecate an endpoint you can specify that an endpoint should not be visible after (and including) a given version group like so: Version(1, deprecateAt: 4) an endpoint marked as above will be visible in all swagger docs up until maxEndpointVersion : 4 . it will be excluded from docs starting from 4 and above. as an example, take to following two endpoints. initial release /user/delete /user/profile release group v1.0 /user/delete/v1 /user/profile/v1 release group v2.0 /user/delete/v1 /user/profile/v2 if you mark the /user/delete/v1 endpoint with Version(1, deprecateAt: 2) then release groups v2.0 and newer will not have any /user/delete endpoints listed. and the release will look like this: release group v2.0 /user/profile/v2 it is only necessary to mark the last endpoint version as deprecated. you can leave all previous iterations alone, if there's any. versioning options at least one of the following settings should be set in order to enable versioning support. Prefix : a string to be used in front of the version (for example 'v' produces 'v1') DefaultVersion : this value will be used for endpoints that do not specify a version in it's configuration. the default value is 0 . when the version of an endpoint is 0 it does not get added to the route making that version the initial version of that endpoint. SuffixedVersion : by default the version string is appended to the endpoint route. by setting this to false , you can have it prepended to the route."
  },
  "wiki/Benchmarks.html": {
    "href": "wiki/Benchmarks.html",
    "title": "Head-To-Head Benchmark | FastEndpoints",
    "keywords": "Head-To-Head Benchmark Method Mean Ratio Gen 0 Gen 1 Allocated FastEndpoints 45.99 s 1.00 2.0000 - 17 KB FastEndpoints (CodeGen) 46.27 s 1.01 2.0000 - 17 KB AspNet 6 Minimal Api 47.22 s 1.03 2.1000 - 18 KB FastEndpoints (Throttling) 48.14 s 1.05 2.2000 - 18 KB FastEndpoints (Scoped Validator) 66.50 s 1.45 3.2000 0.1000 26 KB AspNet 6 MVC Controller 80.51 s 1.75 2.9000 - 24 KB Bombardier Load Test (best out of 5 runs) hardware: AMD Ryzen 7 3700X (8c/16t), 16GB RAM, Windows 11 parameters: -c 512 -m POST -f \"body.json\" -H \"Content-Type:application/json\" -d 30s FastEndpoints (45,000 more requests per second than mvc controller) Statistics Avg Stdev Max Reqs/sec 152719.41 15319.65 237177.27 Latency 3.31ms 233.06us 61.00ms HTTP codes: 1xx - 0, 2xx - 4635227, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 75.30MB/s AspNet Minimal Api Statistics Avg Stdev Max Reqs/sec 149415.35 14544.34 185050.95 Latency 3.38ms 0.89ms 431.99ms HTTP codes: 1xx - 0, 2xx - 4529011, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 75.73MB/s FastEndpoints with throttling Statistics Avg Stdev Max Reqs/sec 137547.83 18167.83 215500.00 Latency 3.69ms 2.02ms 568.63ms HTTP codes: 1xx - 0, 2xx - 4154347, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 72.77MB/s AspNet MVC Controller Statistics Avg Stdev Max Reqs/sec 107381.33 13064.54 184073.63 Latency 4.73ms 1.25ms 416.00ms HTTP codes: 1xx - 0, 2xx - 3245222, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 54.26MB/s TechEmpower Benchmark (Preliminary) <!-- .\\bomb.exe -c 512 -m POST -f \"body.json\" -H \"Content-Type:application/json\" -d 30s http://localhost:5000/benchmark/ok/123 --> <!-- .\\bomb.exe -c 512 -m POST -f \"body.json\" -H \"Content-Type:application/json\" -H \"X-Forwarded-For:000.000.000.000\" -d 30s http://localhost:5000/benchmark/throttle/123 --> <!-- ``` { \"FirstName\": \"xxc\", \"LastName\": \"yyy\", \"Age\": 23, \"PhoneNumbers\": [ \"1111111111\", \"2222222222\", \"3333333333\", \"4444444444\", \"5555555555\" ] } ``` -->"
  },
  "wiki/Configuration-Settings.html": {
    "href": "wiki/Configuration-Settings.html",
    "title": "customizing functionality | FastEndpoints",
    "keywords": "customizing functionality there are several areas you can customize/override the default functionality of the library. all configuration settings must be specified during app startup with the UseFastEndpoints() call. specify json serializer options the settings for the default json serializer which is System.Text.Json can be set like so: app.UseFastEndpoints(c => { c.SerializerOptions = o => { o.PropertyNamingPolicy = JsonNamingPolicy.CamelCase; // set null for pascal case }; }); global route prefix you can have a specified string automatically prepended to all route names in your app instead of repeating it in each and every route config method by specifying the prefix at app startup. app.UseFastEndpoints(c => { c.RoutingOptions = o => o.Prefix = \"api\"; }); for example, the following route config methods would result in the below endpoint routes: Get(\"client/update\"); -> \"/api/client/update\" Put(\"inventory/delete\"); -> \"/api/inventory/delete\" Post(\"sales/recent-list\"); -> \"/api/sales/recent-list\" if needed, you can override or disable the global prefix from within individual endpoints like so: public override void Configure() { Post(\"user/create\"); RoutePrefixOverride(\"mobile\"); } in order to disable the global prefix, simply pass in a string.Empty to the RoutePrefixOverride() method. filtering endpoint auto registration if you'd like to prevent some of the endpoints in your project to be not auto registered during startup, you have the option to supply a filtering function which will be run against each discovered endpoint. if your function returns true , that particular endpoint will be registered. if the function returns false that endpoint will be ignored and not registered. app.UseFastEndpoints(c => { c.EndpointRegistrationFilter = ep => { if (ep.Verbs.Contains(\"GET\") && ep.Routes.Contains(\"/api/mobile/test\")) return false; // don't register this endpoint return true; }; }); it is also possible to set a Tag for an endpoint and use that tag to filter out endpoints according to tags during registration as shown below: public override void Configure() { Get(\"client/update\"); Tags(\"Deprecated\", \"ToBeDeleted\"); //has no relationship with swagger tags } app.UseFastEndpoints(c => { c.EndpointRegistrationFilter = ep => { if (ep.Tags.Contains(\"Deprecated\") is true) return false; // don't register this endpoint return true; }; }); global endpoint options you can have a set of common options applied to each endpoint by specifying an action for the GlobalEndpointOptions property of the configuration. the action you set here will be executed for each endpoint during startup. you can inspect the EndpointDefinition argument to check what the current endpoint is, if needed. options to be applied to endpoints are performed on the RouteHandlerBuilder argument. the action you specify here is executed before Options() and Description() of each individual endpoint during registration. whatever you do here may get overridden or compounded by what you do in the Configure() method of each endpoint. app.UseFastEndpoints(c => { c.GlobalEndpointOptions = (endpoint, builder) => { if (endpoint.Routes[0].StartsWith(\"/api/admin\") is true) { builder .RequireHost(\"admin.domain.com\") .Produces<ErrorResponse>(400, \"application/problem+json\"); } }; }); customizing error responses if the default error response is not to your liking, you can specify a function to produce the exact error response you need. whatever object you return from that function will be serialized to json and sent to the client whenever there needs to be an error response sent downstream. the function will be supplied a collection of validation failures as well as a http status code you can use to construct your own error response object like so: app.UseFastEndpoints(c => { c.ErrorResponseBuilder = (failures, statusCode) => { var list = new List<KeyValuePair<string, string>>(); foreach (var err in failures) list.Add(new(err.PropertyName, err.ErrorMessage)); return list; }; }); customizing de-serialization of json if you'd like to take control of how request bodies are deserialized, simply provide a function like the following. the function is supplied with the incoming http request object, the type of the dto to be created, json serializer context, and a cancellation token. deserialize the object how ever you want and return it from the function. do note that this function will be used to deserialize all incoming requests with a json body. it is currently not possible to specify a deserialization function per endpoint. input parameters: HttpRequest: the http request object Type: the type of the request dto JsonSerializerContext?: nullable json serializer context CancellationToken: a cancellation token config.RequestDeserializer = async (req, tDto, jCtx, ct) => { using var reader = new StreamReader(req.Body); return Newtonsoft.Json.JsonConvert.DeserializeObject(await reader.ReadToEndAsync(), tDto); }; customizing serialization of response dtos the response serialization process can be overridden by specifying a function that returns a Task object. you should set the content-type on the http response object and write directly to the response body stream. do note that this function will be used to serialize all outgoing responses where a json body is required. it is currently not possible to specify a serialization function per endpoint. the parameters supplied to the function are as follows: HttpResponse: the http response object object: the response dto to be serialized string: the response content-type JsonserializerContext?: nullable json serializer context CancellationToken: a cancellation token config.ResponseSerializer = (rsp, dto, cType, jCtx, ct) => { rsp.ContentType = cType; return rsp.WriteAsync(Newtonsoft.Json.JsonConvert.SerializeObject(dto), ct); };"
  },
  "wiki/Dependency-Injection.html": {
    "href": "wiki/Dependency-Injection.html",
    "title": "dependency injection | FastEndpoints",
    "keywords": "dependency injection there are three different ways to get access to services registered in the ioc container. consider the following service registration. the service public interface IHelloWorldService { string SayHello(); } public class HelloWorldService : IHelloWorldService { public string SayHello() => \"hello world!\"; } ioc registration builder.Services.AddScoped<IHelloWorldService, HelloWorldService>(); property injection services can be automatically property injected by simply adding properties to the endpoint like so: public class MyEndpoint : EndpointWithoutRequest { public IHelloWorldService HelloService { get; set; } public override void Configure() { Verbs(Http.GET); Routes(\"/api/hello-world\"); } public override async Task HandleAsync(CancellationToken ct) { await SendAsync(HelloService.SayHello()); } } constructor injection constructor injection is also supported. just make sure not to assign the injected dependencies to public properties if using together with property injection. public class MyEndpoint : EndpointWithoutRequest { private IHelloWorldService _helloService; public MyEndpoint(IHelloWorldService helloScv) { _helloService = helloScv; } public override void Configure() { Verbs(Http.GET); Routes(\"/api/hello-world\"); } public override async Task HandleAsync(CancellationToken ct) { await SendAsync(_helloService.SayHello()); } } manual resolving services can be resolved manually like so: public override async Task HandleAsync(CancellationToken ct) { IHelloWorldService? helloSvc = TryResolve<IHelloWorldService>(); if (helloSvc is null) ThrowError(\"service not resolved!\"); var logger = Resolve<ILogger<MyEndpoint>>(); logger.LogInformation(\"hello service is resolved...\"); await SendAsync(helloSvc.SayHello()); } TryResolve() - this method will try to resolve the given service. returns null if not resolved. Resolve() - this method will throw an exception if the requested service cannot be resolved. pre-resolved services the following services are pre-resolved and available for every endpoint handler with the following properties: property: Config service : IConfiguration property: Env service : IWebHostEnvironment property: Logger service : ILogger they can be used in the endpoint handlers like so: public override async Task HandleAsync(CancellationToken ct) { Logger.LogInformation(\"this is a log message\"); var isProduction = Env.IsProduction(); var smtpServer = Config[\"SMTP:HostName\"]; ... } dependency resolving for validators by default, validators are registered in the DI container as singletons for performance reasons . both the above-mentioned Resolve() and TryResolve() methods are available for validators to get access to the dependencies it needs. you should also take care not to maintain state in the validator due to it being singleton scope. if for some reason you don't mind paying the performance penalty and would like to either maintain state in the validator or would like to do constructor injection, you may do so by instructing the endpoint to register the validator as a scoped dependency like so: public override void Configure() { Get(\"/hello-world\"); ScopedValidator(); } once you enable the validator to be registered as a Scoped dependency, you can use constructor injection on the validator like so: public class MyValidator : Validator<MyRequest> { public MyValidator(IConfiguration config) { if (config is null) throw new ArgumentNullException(nameof(config)); } }"
  },
  "wiki/Domain-Entity-Mapping.html": {
    "href": "wiki/Domain-Entity-Mapping.html",
    "title": "domain entity mapping | FastEndpoints",
    "keywords": "domain entity mapping for those of us who are not fans of AutoMapper and the like, this library offers a cleaner way to do manual mapping for request dto to domain entity and back from an entity to a response dto. consider the following request, response and entity classes: public class Request { public int Id { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string BirthDay { get; set; } } public class Response { public int Id { get; set; } public string UserName { get; set; } public string FullName { get; set; } public int Age { get; set; } } public class Person { public int Id { get; set; } public string FullName { get; set; } public DateOnly DateOfBirth { get; set; } } mapping logic in the endpoint class if you prefer to place your mapping logic in the endpoint definition itself, you can simply use the EndpointWithMapping<TRequest,TResponse,TEntity> generic overload to implement your endpoint and override the MapToEntity() and MapFromEntity() methods like so: public class SavePerson : EndpointWithMapping<Request, Response, Person> { public override void Configure() { Put(\"/api/person\"); AllowAnonymous(); } public override Task HandleAsync(Request r, CancellationToken c) { Person entity = MapToEntity(r); Response = MapFromEntity(entity); return SendAsync(Response); } public override Person MapToEntity(Request r) => new() { Id = r.Id, DateOfBirth = DateOnly.Parse(r.BirthDay), FullName = $\"{r.FirstName} {r.LastName}\" }; public override Response MapFromEntity(Person e) => new() { Id = e.Id, FullName = e.FullName, UserName = $\"USR{e.Id:0000000000}\", Age = (DateOnly.FromDateTime(DateTime.UtcNow).DayNumber - e.DateOfBirth.DayNumber) / 365, }; } mapping logic in a separate class if your preference is to keep the mapping logic in a class of it's own, you can create a separate mapper inheriting from Mapper<TRequest, TResponse, TEntity> like so: public class PersonMapper : Mapper<Request, Response, Person> { public override Person ToEntity(Request r) => new() { Id = r.Id, DateOfBirth = DateOnly.Parse(r.BirthDay), FullName = $\"{r.FirstName} {r.LastName}\" }; public override Response FromEntity(Person e) => new() { Id = e.Id, FullName = e.FullName, UserName = $\"USR{e.Id:0000000000}\", Age = (DateOnly.FromDateTime(DateTime.UtcNow).DayNumber - e.DateOfBirth.DayNumber) / 365, }; } to use the above mapper you need to inherit your endpoint from Endpoint<TRequest, TResponse, TMapper> generic overload like so: public class SavePerson : Endpoint<Request, Response, PersonMapper> { public override void Configure() { Put(\"/api/person\"); AllowAnonymous(); } public override Task HandleAsync(Request r, CancellationToken c) { Person entity = Map.ToEntity(r); Response = Map.FromEntity(entity); return SendAsync(Response); } } the mapping logic can be accessed from the Map property of the endpoint class. that's all there's to it. Note mapper classes are used as singletons for performance reasons. you should not maintain state in your mappers."
  },
  "wiki/Event-Notifications.html": {
    "href": "wiki/Event-Notifications.html",
    "title": "in-process pub/sub notifications | FastEndpoints",
    "keywords": "in-process pub/sub notifications if you'd like to take an event driven approach to building your application, you have the option to publish events from your endpoint handlers and have completely decoupled event-handlers to take action when events are published. it's a simple 3 step process to do event driven work. 1. define an event model/ dto this is the data contract that will be communicated across processes. public class OrderCreatedEvent { public string OrderID { get; set; } public string CustomerName { get; set; } public decimal OrderTotal { get; set; } } 2. define an event handler this is the code that will be fired/executed when events of the above dto type gets published. public class OrderCreationHandler : FastEventHandler<OrderCreatedEvent> { public override Task HandleAsync(OrderCreatedEvent eventModel, CancellationToken ct) { var logger = Resolve<ILogger<OrderCreationHandler>>(); logger.LogInformation($\"order created event received:[{eventModel.OrderID}]\"); return Task.CompletedTask; } } 3. publish the event simply hand in an event model/dto to the PublishAsync() method. public class CreateOrderEndpoint : Endpoint<CreateOrderRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); } public override async Task HandleAsync(CreateOrderRequest req, CancellationToken ct) { var orderID = await orderRepo.CreateNewOrder(req); await PublishAsync(new OrderCreatedEvent { OrderID = orderID, CustomerName = req.Customer, OrderTotal = req.OrderValue }); await SendOkAsync(); } } the PublishAsync() method the PublishAsync() method has an overload that will take a Mode enum that lets you specify whether to wait for all subscribers to finish; wait for any subscriber to finish; or wait for none of the subscribers to finish. for example, you can publish an event in a fire-n-forget manner with the following: await PublishAsync(eventModel, Mode.WaitForNone); the default mode is Mode.WaitForAll which will await all subscribers. i.e. execution will only continue after each and every subscriber of the event has completed their work. publishing from event handlers it is also possible to publish events from within event handlers themselves like so: public class OrderCreationHandler : FastEventHandler<OrderCreatedEvent> { public override async Task HandleAsync(OrderCreatedEvent eventModel, CancellationToken ct) { await PublishAsync(new ReOrderLevelReachedEvent { ItemId = \"ITM-0001\", CurrentLevel = 5, }); } }"
  },
  "wiki/Exception-Handler.html": {
    "href": "wiki/Exception-Handler.html",
    "title": "unhandled exception handler | FastEndpoints",
    "keywords": "unhandled exception handler the library ships with a default exception handler middleware you can use to log the exception details on the server and return a user-friendly http 500 response to the requesting client. example json response: { \"Status\": \"Internal Server Error!\", \"Code\": 500, \"Reason\": \"'x' is an invalid start of a value. Path: $.ValMin | LineNumber: 4...\", \"Note\": \"See application log for stack trace.\" } example server log entry: fail: FastEndpoints.ExceptionHandler[0] ================================= HTTP: POST /inventory/adjust-stock TYPE: JsonException REASON: 'x' is an invalid start of a value. Path: $.ValMin | LineNumber: 4... --------------------------------- at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack& state,... at System.Text.Json.Serialization.JsonConverter`1.ReadCore(Utf8JsonReader& reader,... at System.Text.Json.JsonSerializer.ReadCore[TValue](JsonConverter jsonConverter,... ... enabling the exception handler Program.cs enable the middleware as shown below during app startup. var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); var app = builder.Build(); app.UseDefaultExceptionHandler(); //add this app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); appsettings.json disable the aspnetcore diagnostic logging for unhandled exceptions in order to avoid duplicate log entries. { \"Logging\": { \"LogLevel\": { \"Default\": \"Warning\", \"Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\": \"None\" //add this } }"
  },
  "wiki/File-Handling.html": {
    "href": "wiki/File-Handling.html",
    "title": "handling file uploads | FastEndpoints",
    "keywords": "handling file uploads the following example relays back the image data uploaded to the endpoint in order to demonstrate both receiving and sending of file data: public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/uploads/image\"); AllowFileUploads(); } public override async Task HandleAsync(MyRequest req, CancellationToken ct) { if (Files.Count > 0) { var file = Files[0]; await SendStreamAsync( stream: file.OpenReadStream(), fileName: \"test.png\", fileLengthBytes: file.Length, contentType: \"image/png\"); return; } await SendNoContentAsync(); } } endpoints by default won't allow multipart/form-data content uploads. you'd have to enable file uploads by using the AllowFileUploads() method in the handler configuration like shown above. the received files are exposed to the endpoint handler via the Files property which is of IFormFileCollection type. binding files to dto file data can also be automatically bound to the request dto by simply adding an IFormFile property with a matching name. public class MyRequest { public int Width { get; set; } public int Height { get; set; } public IFormFile File1 { get; set; } public IFormFile File2 { get; set; } public IFormFile File3 { get; set; } } sending file responses there are 3 methods you can use to send file data down to the client. SendStreamAsync() - you can supply a System.IO.Stream to this method for reading binary data from. SendFileAsync() - you can supply a System.IO.FileInfo instance as the source of the binary data. SendBytesAsync() - you can supply a byte array as the source of data to be sent to the client. all three methods allow you to optionally specify the content-type and file name . if file name is specified, the Content-Disposition: attachment response header will be set with the given file name so that a file download will be initiated by the client/browser. range requests/ partial responses are also supported by setting the enableRangeProcessing parameter to true . write to response stream instead of using the above methods, you also have the choice of writing directly to the http response stream. see here for an example project that stores and retrieves images in mongodb."
  },
  "wiki/Get-Started.html": {
    "href": "wiki/Get-Started.html",
    "title": "getting started | FastEndpoints",
    "keywords": "getting started follow the steps below to create your first endpoint that will handle an http post request and send a response back to the client. create a new project create an empty web project with the dotnet cli using the following command or using visual studio. dotnet new web -n MyWebApp install nuget package install the latest library version using the following cli command: dotnet add package FastEndpoints or with nuget package manager: Install-Package FastEndpoints prepare startup replace the contents of Program.cs file with the following: global using FastEndpoints; var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); var app = builder.Build(); app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); add a request dto create a file called MyRequest.cs and add the following: public class MyRequest { public string FirstName { get; set; } public string LastName { get; set; } public int Age { get; set; } } add a response dto create a file called MyResponse.cs and add the following: public class MyResponse { public string FullName { get; set; } public bool IsOver18 { get; set; } } add an endpoint definition create a file called MyEndpoint.cs and add the following: public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); AllowAnonymous(); } public override async Task HandleAsync(MyRequest req, CancellationToken ct) { var response = new MyResponse() { FullName = req.FirstName + \" \" + req.LastName, IsOver18 = req.Age > 18 }; await SendAsync(response); } } now run your web app and send a POST request to the /api/user/create endpoint using a REST client such as postman with the following request body: { \"FirstName\": \"marlon\", \"LastName\": \"brando\", \"Age\": 40 } you should then get a response back such as this: { \"FullName\": \"marlon brando\", \"IsOver18\": true } that's all there's to it. you simply configure how the endpoint should be listening to incoming requests from clients in the Configure() section calling methods such as Verbs() , Routes() , AllowAnonymous() , etc. then you override the HandleAsync() method in order to specify your handling logic. the request dto is automatically populated from the json body of your http request and passed in to the handler. when you're done processing, you call the SendAsync() method with a new response dto to be sent to the requesting client. endpoint types there are 4 different endpoint base types you can inherit from. Endpoint<TRequest> - use this type if there's only a request dto. you can however send any object to the client that can be serialized as a response with this generic overload. Endpoint<TRequest,TResponse> - use this type if you have both request and response dtos. the benefit of this generic overload is that you get strongly-typed access to properties of the dto when doing integration testing and validations. EndpointWithoutRequest - use this type if there's no request nor response dto. you can send any serializable object as a response here also. EndpointWithoutRequest<TResponse> - use this type if there's no request dto but there is a response dto. it is also possible to define endpoints with EmptyRequest and EmptyResponse if needed like so: public class MyEndpoint : Endpoint<EmptyRequest,EmptyResponse> { } sending responses there are multiple response sending methods you can use. it is also possible to simply populate the Response property of the endpoint and get a 200 ok response with the value of the Response property serialized in the body automatically. for ex: response dto: public class MyResponse { public string FullName { get; set; } public int Age { get; set; } } endpoint definition: public class MyEndpoint : EndpointWithoutRequest<MyResponse> { public override void Configure() { Get(\"/api/person\"); AllowAnonymous(); } public override async Task HandleAsync(CancellationToken ct) { var person = await dbContext.GetFirstPersonAsync(); Response.FullName = person.FullName; Response.Age = person.Age; } } assigning a new instance to the Response property also has the same effect: public override Task HandleAsync(CancellationToken ct) { Response = new() { FullName = \"john doe\", Age = 124 }; return Task.CompletedTask; } configuring endpoints using attributes instead of overriding the Configure() method, endpoint classes can be annotated with [HttpGet(...)] , [AllowAnonymous] , and [Authorize(...)] attributes. advanced usage however does require overriding Configure() . you can only use one of these strategies for configuring endpoints. an exception will be thrown if you use both or none at all. [HttpPost(\"/my-endpoint\")] [Authorize(Roles = \"Admin,Manager\")] public class UpdateAddress : Endpoint<MyRequest, MyResponse> { public override async Task HandleAsync(MyRequest req, CancellationToken ct) { await SendAsync(new MyResponse { }); } }"
  },
  "wiki/Integration-Testing.html": {
    "href": "wiki/Integration-Testing.html",
    "title": "route-less integration testing | FastEndpoints",
    "keywords": "route-less integration testing the recommended approach to test your endpoints is to perform integration testing using the WebApplicationFactory . this library offers a set of extensions to the HttpClient to make testing more convenient in a strongly-typed and route-less manner. i.e. you don't need to specify the route urls when testing endpoints. follow the simple steps below to start WAF testing your endpoints: Note this document is still a work-in-progress. please check back soon... you can have a look at the test project here in the meantime to get an idea. unit testing endpoints if you don't mind paying the price of extra work needed for more granular testing with unit tests, you may use the Factory.Create<TEndpoint>() method to get an instance of your endpoint which is suitable for unit testing. [TestMethod] public async Task AdminLoginSuccess() { //arrange var fakeConfig = A.Fake<IConfiguration>(); A.CallTo(() => fakeConfig[\"TokenKey\"]).Returns(\"0000000000000000\"); var ep = Factory.Create<AdminLogin>( A.Fake<ILogger<AdminLogin>>(), //mock dependencies for injecting to the constructor A.Fake<IEmailService>(), fakeConfig); var req = new AdminLoginRequest { UserName = \"admin\", Password = \"pass\" }; //act await ep.HandleAsync(req, default); var rsp = ep.Response; //assert Assert.IsNotNull(rsp); Assert.IsFalse(ep.ValidationFailed); Assert.IsTrue(rsp.Permissions.Contains(\"Inventory_Delete_Item\")); } use the Factory.Create() method by passing it the mocked dependencies which are needed by the endpoint constructor, if there's any. it has multiple overloads that enables you to instantiate endpoints with or without constructor arguments. then simply execute the handler by passing in a request dto and a default cancellation token. finally do your assertions on the Response property of the endpoint instance. handler method which returns the response dto if you prefer to return the dto object from your handler, you can implement the ExecuteAsync() method instead of HandleAsync() like so: public class AdminLogin : Endpoint<Request, Response> { public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); } public override Task<Response> ExecuteAsync(Request req, CancellationToken ct) { return Task.FromResult( new Response { JWTToken = \"xxx\", ExpiresOn = \"yyy\" }); } } by doing the above, you can simply access the response dto like below instead of through the Response property of the endpoint when unit testing. var res = await ep.ExecuteAsync(req, default);"
  },
  "wiki/Misc-Conveniences.html": {
    "href": "wiki/Misc-Conveniences.html",
    "title": "endpoint options | FastEndpoints",
    "keywords": "endpoint options in addition to the convenient methods you can use in the endpoint configuration to setup your endpoints (mentioned in previous pages), you can use the Options() method to customize aspects of endpoint registration/setup like so: Options(b => b.RequireCors(x => x.AllowAnyOrigin()) .RequireHost(\"domain.com\") .ProducesProblem(404)); shorthand route configuration instead of the Verbs() and Routes() combo, you can use the shorthand versions that combines them with Get(), Post(), Put(), Patch(), Delete() when configuring your endpoints like so: public override void Configure( ) { Get(\"/api/customer/{CustomerID}\"); } the above is equivalent to using both Verbs() and Routes() . do note that you can't configure multiple verbs with the shorthand version. you can however setup multiple route patterns with the shorthand methods. endpoint properties the following properties are available to all endpoint classes. BaseURL (string) the base url of the current request in the form of https://hostname:port/ (includes trailing slash). if your server is behind a proxy/gateway, use the forwarded headers middleware to get the correct address. Config (IConfiguration) gives access to current configuration of the web app Env (IWebHostEnvironment) gives access to the current web hosting environment Files (IFormFileCollection) exposes the uploaded file collection in case of multipart/form-data uploads. Form (IFormCollection) exposes the form data in case of application/x-www-form-urlencoded or multipart/form-data uploads. HttpContext (HttpContext) gives access to the current http context of the request. HttpMethod (Http enum value) the http method of the current request as an enum value. Logger (ILogger) the default logger for the current endpoint type Response (TResponse) exposes a blank response dto for the current endpoint before the endpoint handler is executed. or represents the populated response dto after a response has been sent to the client. User (ClaimsPrincipal) the current claims principal associated with the current request. ValidationFailed (bool) indicates the current validation status ValidationFailures (List<ValidationFailure>) the list of validation failures for the current execution context. send methods the following response sending methods are available for use from within endpoint handlers: SendAsync() sends a given response dto or any object that can be serialized as json down to the requesting client. SendCreatedAtAsync() sends a 201 created response with a Location header containing where the resource can be retrieved from. see note about using with custom endpoint names. SendStringAsync() sends a given string to the client in the response body SendOkAsync() sends a 200 ok response without any body. SendNoContentAsync() sends a 204 no content response SendRedirectAsync() sends a 30X moved response with a location header containing the url to redirect to. SendErrorsAsync() sends a 400 error response with the current list of validation errors describing the validation failures. SendNotFoundAsync() sends a 404 not found response SendUnauthorizedAsync() sends a 401 unauthorized response SendForbiddenAsync() sends a 403 unauthorized response SendBytesAsync() sends a byte array to the client SendFileAsync() sends a file to the client SendStreamAsync() sends the contents of a stream to the client SendEventStreamAsync() sends a \"server-sent-events\" data stream to the client hook methods the following 4 hook methods allow you to do something before and after dto validation as well as handler execution. OnBeforeValidate() override this method if you'd like to do something to the request dto before it gets validated. OnAfterValidate() override this method if you'd like to do something to the request dto after it gets validated. OnBeforeHandle() override this method if you'd like to do something to the request dto before the handler is executed. OnAfterHandle() override this method if you'd like to do something after the handler is executed."
  },
  "wiki/Model-Binding.html": {
    "href": "wiki/Model-Binding.html",
    "title": "request dto binding | FastEndpoints",
    "keywords": "request dto binding the endpoint handlers are supplied with fully populated request dtos. the dto property values are automatically bound from the incoming request, from the following sources in the exact order: json body form data route parameters query parameters user claims (if property has [FromClaim] attribute) http headers (if property has [FromHeader] attribute) permissions (if boolean property has [HasPermission] attribute) consider the following request dto and http request: dto public class GetUserRequest { public string UserID { get; set; } } http request route : /api/user/{UserID} url : /api/user/54321 json : { \"UserID\": \"12345\" } when the handler receives the request dto, the value of UserID will be 54321 because route parameters have higher priority than json body. likewise, if you decorate the UserID property with [FromClaim] attribute like so: public class GetUserRequest { [FromClaim] public string UserID { get; set; } } the value of UserID will be whatever claim value the user has for the claim type UserID in their claims. by default if the user does not have a claim type called UserID , then a validation error will be sent automatically to the client. you can make the claim optional by using the following overload of the attribute: [FromClaim(IsRequired = false)] doing so will allow the endpoint handler to execute even if the current user doesn't have the specified claim and model binding will take the value from the highest priority source of the other binding sources mentioned above (if a matching field/route param is present). an example can be seen here . it is also possible to model bind automatically from http headers like so: public class GetUserRequest { [FromHeader] public string TenantID { get; set; } } FromHeader attribute will also by default send an error response if a http header (with the same name as the property being bound to) is not present in the incoming request. you can make the header optional and turn off the default behavior by doing [FromHeader(IsRequired = false)] just like with the FromClaim attribute. Both attributes have the same overloads and behaves similarly. the HasPermission attribute can be used on boolean properties to check if the current user principal has a particular permission like so: public class UpdateArticleRequest { [HasPermission(\"Article_Update\")] public bool AllowedToUpdate { get; set; } } the property value will be set to true if the current principal has the Article_Update permission. as with the above attributes, an automatic validation error will be sent in case the principal does not have the specified permission. you can disable the automatic validation error by doing the following: [HasPermission(\"Article_Update\", IsRequired = false)] route parameters route parameters can be bound to properties on the dto using route templates like you'd typically do. request dto public class MyRequest { public string MyString { get; set; } public bool MyBool { get; set; } public int MyInt { get; set; } public long MyLong { get; set; } public double MyDouble { get; set; } public decimal MyDecimal { get; set; } } endpoint public class MyEndpoint : Endpoint<MyRequest> { public override void Configure() { Verbs(Http.GET); Routes(\"/api/{MyString}/{MyBool}/{MyInt}/{MyLong}/{MyDouble}/{MyDecimal}\"); } } if a GET request is made to the url /api/hello world/true/123/12345678/123.45/123.4567 the request dto would have the following property values: MyString - \"hello world\" MyBool - true MyInt - 123 MyLong - 12345678 MyDouble - 123.45 MyDecimal - 123.4567 query parameters in order to bind from query string params, simply use a url that has the same param names as your request dto such as: /api/hello-world/?Message=hello+from+query+string if your request dto has a property called Message it would then have hello from query string as it's value. complex model binding complex model binding is only supported from the json body. for example, the following request dto will be automatically populated from the below json request body. request dto public class UpdateAddressRequest { public int UserID { get; set; } public Address UserAddress { get; set; } public class Address { public string Street { get; set; } public string City { get; set; } public string Country { get; set; } } } json request body { \"UserID\": 111, \"Address\": { \"Street\": \"123 road\", \"City\": \"new york\", \"Country\": \"usa\" } } mismatched property names you can bind to dto properties when the incoming parameter name doesn't match with the name of the property being bound to, depending on the type of the parameter source like so: json body [JsonPropertyName(\"address\")] public Address UserAddress { get; set; } form fields, route params & query params: [BindFrom(\"customerId\")] public string CustomerID { get; set; } headers & claims: [FromHeader(\"tenant-id\")] public string TenantID { get; set; } [FromClaim(\"user-id\")] public string UserID { get; set; } supported property types json body: any complex type can be bound as long as the System.Text.Json serializer can handle it. if it's not supported out of the box, please see the STJ documentation on how to implement custom converters for your types. you can register your custom converters in startup like this: app.UseFastEndpoints(c => { c.SerializerOptions = o => { o.SerializerOptions.Converters.Add(new CustomConverter()); }; }); form fields/route/query/claims/headers: simple strings can be bound automatically to any of the primitive/clr types such as the following that has a static TryParse() method: bool double decimal DateTime Enum Guid int long string TimeSpan Uri Version in order to support binding your custom types from route/query/claims/header/form fields, simply add a static TryParse() method to your type like the example below: public class Point { public double X { get; set; } public double Y { get; set; } public static bool TryParse(string? input, out Point? output) //adhere to this signature { output = null; if (string.IsNullOrEmpty(input)) { return false; } var parts = input.Split(','); if (!double.TryParse(parts[0], out var x) || !double.TryParse(parts[1], out var y)) { return false; } output = new Point { X = x, Y = y }; return true; } } route/query binding when there's no request dto if your endpoint doesn't have/need a request dto, you can easily read route & query parameters using the Route<T>() and Query<T>() methods. public class GetArticle : EndpointWithoutRequest { public override void Configure() { Get(\"/article/{ArticleID}\"); AllowAnonymous(); } public override Task HandleAsync(CancellationToken ct) { //http://localhost:5000/article/123 int routeParam = Route<int>(\"ArticleID\"); //http://localhost:5000/article/123?OtherID=8635ffb2-6589-4629-85bc-29f2cce5a12d Guid queryParam = Query<Guid>(\"OtherID\"); } } note: Route<T>() & Query<T>() methods are also only able to handle types that have a static TryParse() method as mentioned above. if there's no static TryParse() method or if parsing fails, an automatic validation failure response is sent to the client. this behavior can be turned off with the following overload: Route<Point>(\"ArticleID\", isRequired: false); Query<Guid>(\"OtherID\", isRequired: false); binding to raw request content if you need to access the raw request content as a string, you can achieve that by implementing the interface IPlainTextRequest like so: public class Request : IPlainTextRequest { public string Content { get; set; } } when your dto implements IPlainTextRequest , json model binding won't occur. instead, the Content property is populated with the content of the request body. other properties can also be added to your dto in case you need to access some other values like route/query/form field/header/claim values. json serialization casing by default the serializer uses camel casing for serializing/deserializing. you can change the casing as shown in the configuration settings section. json source generator support the System.Text.Json source generator support can be easily enabled with a simple 2 step process: step 1: create a serializer context [JsonSerializable(typeof(RequestModel))] [JsonSerializable(typeof(ResponseModel))] public partial class UpdateAddressCtx : JsonSerializerContext { } step 2: specify the serializer context for the endpoint public class UpdateAddress : Endpoint<RequestModel, ResponseModel> { public override void Configure() { Post(\"user/address\"); SerializerContext(UpdateAddressCtx.Default); } }"
  },
  "wiki/Pre-Post-Processors.html": {
    "href": "wiki/Pre-Post-Processors.html",
    "title": "pre/post processors | FastEndpoints",
    "keywords": "pre/post processors rather than writing a common piece of logic repeatedly that must be executed either before or after each request to your system, you can write it as a processor and attach it to endpoints that need them. there are two types of processors. pre-processors and post-processors . pre-processors let's say for example that you'd like to log every request before being executed by your endpoint handlers. you can simply write a pre-processor like below by implementing the interface IPreProcessor<TRequest> : public class MyRequestLogger<TRequest> : IPreProcessor<TRequest> { public Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<TRequest>>(); logger.LogInformation($\"request:{req?.GetType().FullName} path: {ctx.Request.Path}\"); return Task.CompletedTask; } } and then attach it to the endpoints you need like so: public class CreateOrderEndpoint : Endpoint<CreateOrderRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); PreProcessors(new MyRequestLogger<CreateOrderRequest>()); } } you can even write a request dto specific processor like so: public class SalesRequestLogger : IPreProcessor<CreateSaleRequest> { public Task PreProcessAsync(CreateSaleRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<CreateSaleRequest>>(); logger.LogInformation($\"sale value:{req.SaleValue}\"); return Task.CompletedTask; } } short-circuiting execution it is possible to end processing the request by returning a response from within a pre-processor like so: public class SecurityProcessor<TRequest> : IPreProcessor<TRequest> { public Task PreProcessAsync(TRequest req, HttpContext ctx, List<ValidationFailure> failures, CancellationToken ct) { var tenantID = ctx.Request.Headers[\"tenant-id\"].FirstOrDefault(); if (tenantID == null) { failures.Add(new(\"MissingHeaders\", \"The [tenant-id] header needs to be set!\")); return ctx.Response.SendErrorsAsync(failures); //sending response here } if (tenantID != \"qwerty\") return ctx.Response.SendForbiddenAsync(); //sending response here return Task.CompletedTask; } } all the Send* methods supported by endpoint handlers are available. the send methods are accessed from the ctx.Response property as shown above. when a response is sent from a pre-processor, the handler method is not executed. however, if there are multiple pre-processors configured, they will be executed. if another pre-processor also wants to send a response, they must check if it's possible to do so by checking the property ctx.Response.HasStarted to see if a previously executed pre-processor has already sent a response to the client. post-processors post-processors are executed after your endpoint handler has completed it's work. they can be created similarly by implementing the interface IPostProcessor<TRequest, TResponse> : public class MyResponseLogger<TRequest, TResponse> : IPostProcessor<TRequest, TResponse> { public Task PostProcessAsync(TRequest req, TResponse res, HttpContext ctx, IReadOnlyCollection<ValidationFailure> failures, CancellationToken ct) { var logger = ctx.RequestServices.GetRequiredService<ILogger<TResponse>>(); if (res is CreateSaleResponse response) { logger.LogWarning($\"sale complete: {response.OrderID}\"); } return Task.CompletedTask; } } and then attach it to endpoints like so: public class CreateOrderEndpoint : Endpoint<CreateSaleRequest, CreateSaleResponse> { public override void Configure() { Verbs(Http.POST); Routes(\"/sales/orders/create\"); PostProcessors(new MyResponseLogger<CreateSaleRequest, CreateSaleResponse>()); } } multiple processors you can attach multiple processors with both PreProcessors() and PostProcessors() methods. the processors are executed in the order they are supplied to the methods. global processors/ filters the recommended approach for global filters/ processors is to write that logic as a middleware and register it in the asp.net pipeline like so: app.UseMiddleware<MyMiddleware>() as an alternative to that, you can write a base endpoint like below which includes a processor and derive your endpoint classes from that. public abstract class PublicEndpoint<TRequest, TResponse> : Endpoint<TRequest, TResponse> where TRequest : class, new() where TResponse : notnull, new() { public override void Configure() { PreProcessors(new MyRequestLogger<TRequest>()); AllowAnonymous(); } } public class MyEndpoint : PublicEndpoint<EmptyRequest, EmptyResponse> { public override void Configure() { Get(\"test/global-preprocessor\"); base.Configure(); } public override Task HandleAsync(EmptyRequest req, CancellationToken ct) { return SendOkAsync(); } } this approach is also helpful if you'd like to configure several endpoints with the same base configuration."
  },
  "wiki/Rate-Limiting.html": {
    "href": "wiki/Rate-Limiting.html",
    "title": "endpoint rate limiting | FastEndpoints",
    "keywords": "endpoint rate limiting it is possible to rate limit individual endpoints based on the presence of an http header in the incoming request like below: public override void Configure() { Post(\"/order/create\"); Throttle( hitLimit: 120, durationSeconds: 60, headerName: \"X-Client-Id\"); //this is optional } hit limit & window duration the above for example will only allow 120 requests from each unique client (identified by the header value) within a 60 second window. if 121 requests are made by a client within 60 seconds, a 429 too many requests response will be automatically sent for the 121st request. the counter is reset every 60 seconds and the client is able to make another 120 requests in the next 60 seconds, and so on. header name the header name can be set to anything you prefer. if it's not specified, the library will try to read the value of X-Forwarded-For header from the incoming request. if that's unsuccessful, it will try to read the HttpContext.Connection.RemoteIpAddress in order to uniquely identify the client making the request. if all attempts are unsuccessful, a 403 forbidden response will be sent. header reliability both X-Forwarded-For and HttpContext.Connection.RemoteIpAddress could be unreliable for uniquely identifying clients if they are behind a NAT, reverse proxy, or anonymizing vpn/proxy etc. therefore, the recommended strategy is to generate a unique identifier such as a GUID in your client application and use that as the header value in each request for the entirety of the session/app cycle. limitations & warnings should not be used for security or ddos protection. a malicious client can easily set a unique header value per request in order to circumvent the throttling. should be aware of the slight performance degradation due to resource allocation and amount of work being done. only per endpoint limits can be set. no global limits can be enforced. this won't ever be added due to performance reasons. consider a rate limiting solution that is out of process/ at the gateway level for better performance/security."
  },
  "wiki/Response-Caching.html": {
    "href": "wiki/Response-Caching.html",
    "title": "response caching | FastEndpoints",
    "keywords": "response caching in order to get response caching working, you need to enable the response caching middleware and define how responses are cached using the ResponseCache() method in the endpoint configuration. this method supports all arguments of the [ResponseCache] attribute you'd typically use with mvc except for the CacheProfileName argument as cache profiles are not supported. see this document for an intro to response caching in asp.net middleware. startup global using FastEndpoints; var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddResponseCaching(); //add this var app = builder.Build(); app.UseAuthorization(); app.UseResponseCaching(); //add this app.UseFastEndpoints(); app.Run(); endpoint public class MyEndpoint : EndpointWithoutRequest { public override void Configure() { Verbs(Http.GET); Routes(\"/api/cached-ticks\"); ResponseCache(60); //cache for 60 seconds } public override Task HandleAsync(CancellationToken ct) { return SendAsync(new { Message = \"this response is cached\" Ticks = DateTime.UtcNow.Ticks }); } }"
  },
  "wiki/Security.html": {
    "href": "wiki/Security.html",
    "title": "securing endpoints | FastEndpoints",
    "keywords": "securing endpoints endpoints are secure by default and you'd have to call AllowAnonymous() in the configuration if you'd like to allow unauthenticated users to access a particular endpoint. jwt bearer authentication support for easy jwt bearer authentication is provided. you simply need to install the FastEndpoints.Security package and register it in the middleware pipeline like so: program.cs global using FastEndpoints; global using FastEndpoints.Security; //add this var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddAuthenticationJWTBearer(\"TokenSigningKey\"); //add this var app = builder.Build(); app.UseAuthentication(); //add this app.UseAuthorization(); app.UseFastEndpoints(); app.Run(); generating jwt tokens you can generate a jwt token for sending to the client with an endpoint that signs in users like so: public class UserLoginEndpoint : Endpoint<LoginRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/login\"); AllowAnonymous(); } public override async Task HandleAsync(LoginRequest req, CancellationToken ct) { if (req.Username == \"admin\" && req.Password == \"pass\") { var jwtToken = JWTBearer.CreateToken( signingKey: \"TokenSigningKey\", expireAt: DateTime.UtcNow.AddDays(1), claims: new[] { (\"Username\", req.Username), (\"UserID\", \"001\") }, roles: new[] { \"Admin\", \"Management\" }, permissions: new[] { \"ManageInventory\", \"ManageUsers\" }); await SendAsync(new { Username = req.Username, Token = jwtToken }); } else { ThrowError(\"The supplied credentials are invalid!\"); } } } endpoint authorization once an authentication provider is registered such as jwt bearer as shown above, you can restrict access to users based on the following: policies claims roles permissions pre-built security policies security policies can be pre-built and registered during app startup and endpoints can choose to allow access to users based on the registered policy names like so: startup builder.Services.AddAuthorization(o => o.AddPolicy(\"ManagersOnlyPolicy\", b => b.RequireRole(\"Manager\") .RequireClaim(\"ManagerID\"))); endpoint public class UpdateUserEndpoint : Endpoint<UpdateUserRequest> { public override void Configure() { Verbs(Http.PUT); Routes(\"/api/users/update\"); Policies(\"ManagersOnlyPolicy\"); } } declarative security policies instead of registering each security policy at startup you can selectively specify security requirements for each endpoint in the endpoint configuration itself like so: public class RestrictedEndpoint : Endpoint<RestrictedRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/restricted\"); Claims(\"AdminID\", \"EmployeeID\"); Roles(\"Admin\", \"Manager\"); Permissions(\"UpdateUsersPermission\", \"DeleteUsersPermission\"); } } Claims() method with this method you are specifying that if a user principal has ANY of the specified claims, access should be allowed. if the requirement is to allow access only if ALL specified claims are present, you can use the ClaimsAll() method. Permissions() method just like above, you can specify that ANY of the specified permissions should allow access. Or require ALL of the specified permissions by using the PermissionsAll() method. Roles() method similarly, you are specifying that ANY of the given roles should allow access to a user principal who has it. AllowAnonymous() method use this method if you'd like to allow unauthenticated users to access a particular endpoint. it is also possible to specify which http verbs you'd like to allow anonymous access to like so: public class RestrictedEndpoint : Endpoint<RestrictedRequest> { public override void Configure() { Verbs(Http.POST, Http.PUT, Http.PATCH); Routes(\"/api/restricted\"); AllowAnonymous(Http.POST); } } the above endpoint is listening for all 3 http methods on the same route but only POST method is allowed to be accessed anonymously. it is useful for example when you'd like to use the same handler logic for create/replace/update scenarios and create operation is allowed to be done by anonymous users. using just AllowAnonymous() without any arguments means all verbs are allowed anonymous access. other auth providers all auth providers compatible with the asp.net middleware pipeline can be registered and used like above. the only difference is that you use the methods mentioned above to restrict access to endpoints rather than using the [Authorize] attribute as you would typically do. Tip here's an example project using Auth0 with permissions. multiple authentication schemes it is possible to register multiple auth schemes at startup and specify per endpoint which schemes are to be used for authenticating incoming requests. startup builder.Services.AddAuthentication(o => { o.DefaultAuthenticateScheme = CookieAuthenticationDefaults.AuthenticationScheme; o.DefaultChallengeScheme = CookieAuthenticationDefaults.AuthenticationScheme; }) .AddCookie(o => o.SlidingExpiration = true) // cookie auth .AddJwtBearer(o => // jwt bearer auth { o.Authority = $\"https://{builder.Configuration[\"Auth0:Domain\"]}/\"; o.Audience = builder.Configuration[\"Auth0:Audience\"]; }); endpoint public override void Configure() { Get(\"/account/profile\"); AuthSchems(JwtBearerDefaults.AuthenticationScheme); } in the above example, we're registering both cookie and jwt bearer auth schemes and in the endpoint we're saying only jwt bearer auth scheme should be used for authenticating incoming requests to the endpoint. you can specify multiple schemes and if an incoming request isn't using any of the said schemes, access will not be allowed."
  },
  "wiki/Server-Sent-Events.html": {
    "href": "wiki/Server-Sent-Events.html",
    "title": "server-sent-events | FastEndpoints",
    "keywords": "server-sent-events server-sent-events can be used to push real-time data down to the web browser in an async manner without blocking threads using the IAsyncIEnumerable interface like so: public class EventStream : EndpointWithoutRequest { public override void Configure() { Get(\"event-stream\"); AllowAnonymous(); Options(x => x.RequireCors(p => p.AllowAnyOrigin())); } public override async Task HandleAsync(CancellationToken ct) { //simply provide any IAsyncEnumerable<T> as argument await SendEventStream(\"my-event\", GetDataStream(ct), ct); } private async IAsyncEnumerable<object> GetDataStream( [EnumeratorCancellation] CancellationToken cancellation) { while (!cancellation.IsCancellationRequested) { await Task.Delay(1000); yield return new { guid = Guid.NewGuid() }; } } } in the browser, the event stream can be subscribed to and consumed using the EventSource object like so: <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\" /> </head> <body> <script> var sse = new EventSource('http://localhost:8080/event-stream'); sse.addEventListener(\"my-event\", e => console.log(e.data)) </script> </body> </html> if you are planning to create more than a handful of server-sent-event streams, it's a good idea to enable http2 in kestrel and all upstream servers such as reverse proxies and CDNs so that data can be multiplexed between the web server and client using a low number of tcp connections. here's a good read on the subject."
  },
  "wiki/Swagger-Support.html": {
    "href": "wiki/Swagger-Support.html",
    "title": "swagger support | FastEndpoints",
    "keywords": "swagger support swagger support is provided via the excellent NSwag library. your mileage may vary since nswag is presently tied closely to the mvc framework and support for .net 6 minimal api is lacking in some areas. if you find some rough edges with the swagger support in FastEndpoints, please get in touch by creating a github issue or submit a pull request if you have experience dealing with swagger. enable swagger first install the FastEndpoints.Swagger package and add 4 lines to your app startup: global using FastEndpoints; using FastEndpoints.Swagger; //add this var builder = WebApplication.CreateBuilder(); builder.Services.AddFastEndpoints(); builder.Services.AddSwaggerDoc(); //add this var app = builder.Build(); app.UseAuthorization(); app.UseFastEndpoints(); app.UseOpenApi(); //add this app.UseSwaggerUi3(s => s.ConfigureDefaults()); //add this app.Run(); you can then visit /swagger or /swagger/v1/swagger.json to see swagger output. configuration swagger options can be configured as you'd typically do via the AddSwaggerDoc() method: builder.Services.AddSwaggerDoc(settings => { settings.Title = \"My API\"; settings.Version = \"v1\"; }); describe endpoints by default, both Accepts and Produces metadata are inferred from the request/response dto types of your endpoints and added to the swagger document automatically. so you only need to specify the additional accepts/produces metadata using the Description() method like so: public class MyEndpoint : Endpoint<MyRequest, MyResponse> { public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Description(b => b .Produces<ErrorResponse>(400,\"application/json+problem\") .ProducesProblem(403)); } } if the default Accepts & Produces are not to your liking, you can clear the defaults and do it all yourself by setting the clearDefaults argument to true : public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Description(b => b .Accepts<MyRequest>(\"application/json+custom\") .Produces<MyResponse>(200, \"application/json+custom\") .Produces<ErrorResponse>(400, \"application/json+problem\") .ProducesProblem(403), clearDefaults: true); } swagger documentation the text descriptions for the endpoint and the different responses the endpoint returns can be specified with the Summary() method: public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Description(b => b .ProducesProblem(403)); Summary(s => { s.Summary = \"short summary goes here\"; s.Description = \"long description goes here\"; s[200] = \"success response description goes here\"; s[403] = \"forbidden response description goes here\"; }); } if you prefer to move the summary text out of the endpoint class, you can do so by subclassing the EndpointSummary type: class AdminLoginSummary : EndpointSummary { public AdminLoginSummary() { Summary = \"short summary goes here\"; Description = \"long description goes here\"; this[200] = \"success response description goes here\"; this[403] = \"forbidden response description goes here\"; } } public override void Configure() { Post(\"/admin/login\"); AllowAnonymous(); Description(b => b .ProducesProblem(403)); Summary(new AdminLoginSummary()); } describe request params route parameters, query parameters and request dto property descriptions can be specified either with xml comments or with the Summary() method or EndpointSummary subclassing. take the following for example: request dto: /// <summary> /// the admin login request summary /// </summary> public class Request { /// <summary> /// username field description /// </summary> public string UserName { get; set; } /// <summary> /// password field description /// </summary> public string Password { get; set; } } endpoint config: public override void Configure() { Post(\"admin/login/{ClientID?}\"); AllowAnonymous(); Options(b => b.RequireCors(b => b.AllowAnyOrigin())); Summary(s => { s.Summary = \"summary\"; s.Description = \"description\"; s.Params[\"ClientID\"] = \"client id description\"); s.RequestParam(r => r.UserName, \"overriden username description\"); }); } use the s.Params dictionary to specify descriptions for params that don't exist on the request dto or when there is no request dto. use the s.RequestParam() method to specify descriptions for properties of the request dto in a strongly-typed manner. whatever you specify within the Summary() method as above takes higher precedence over xml comments. enabling xml documentation xml documentation is only supported for request/response dtos (swagger schemas) which can be enabled by adding the following to the csproj file: <PropertyGroup> <GenerateDocumentationFile>true</GenerateDocumentationFile> <NoWarn>CS1591</NoWarn> </PropertyGroup> if you can figure out how to get nswag to read the xml summary/remarks tags from the endpoint classes, please submit a PR on github. adding query params to swagger document in order to let swagger know that a particular request dto property is being bound from a query string parameter, you need to decorate that property with the [QueryParam] attribute like below. when you annotate a property with the [QueryParam] attribute, a query parameter will be added to the swagger document for that property. public class CreateEmployeeRequest { [QueryParam] public string Name { get; set; } //bound from query string [QueryParam, BindFrom(\"id\")] public string? ID { get; set; } //bound from query string public Address Address { get; set; } //bound from body } the [QueryParam] attribute does not affect the model binding order in any way. it is just a way to make swagger add a query param. disable jwt auth scheme support for jwt bearer auth is automatically added. if you need to disable it, simply pass a false value to the following parameter: builder.Services.AddSwaggerDoc(addJWTBearerAuth: false); multiple authentication schemes multiple global auth scheme support can be enabled by using the AddAuth() method like below. builder.Services.AddSwaggerDoc(s => { s.DocumentName = \"Release 1.0\"; s.Title = \"Web API\"; s.Version = \"v1.0\"; s.AddAuth(\"ApiKey\", new() { Name = \"api_key\", In = OpenApiSecurityApiKeyLocation.Header, Type = OpenApiSecuritySchemeType.ApiKey, }); s.AddAuth(\"Bearer\", new() { Type = OpenApiSecuritySchemeType.Http, Scheme = \"Bearer\", BearerFormat = \"JWT\", }); }); doing the above will associate each of the auth schemes with all endpoints/ swagger operations. if some of your endpoints are only using a a few, they can be specified per endpoint with the AuthSchemes() endpoint method , in which case only the relevant auth schemes will be associated with each swagger operation. for example, if you have both ApiKey and Bearer schemes enabled in swagger and an endpoint only uses ApiKey scheme, when you hit the Try It Out button in swagger ui, only api key auth prompt will be shown. group endpoints by path segment (auto tagging) if you'd like to group your endpoints by a segment of the route url, simply specify an integer indicating which segment to use for tagging/grouping. builder.Services.AddSwaggerDoc(tagIndex: 2) overriding auto tagging if you have auto tagging enabled but would like to prevent a particular endpoint from being auto tagged, you can call the DontAutoTag() method in endpoint configuration to prevent a tag based on a path segment from being added. manual tagging if you'd like to take control of the tagging behavior, simply set tagIndex: 0 to disable auto tagging of endpoints and specify a tag for each endpoint via Description(x => x.WithTags(\"xyz\")) method. customize swagger schema names by default, schema names are generated using the full name of dto classes. you can make the schema names be just the class name. builder.Services.AddSwaggerDoc(shortSchemaNames: true); swagger serializer options even though nswag uses a separate serializer (newtonsoft) internally, we specify serialization settings for nswag using System.Text.Json.JsonSerializerOptions just so we don't have to deal with anything related to newtonsoft (until nswag fully switches over to System.Text.Json). builder.Services.AddSwaggerDoc(serializerSettings: x => { x.PropertyNamingPolicy = null; x.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull; ... }); with the above approach, System.Text.Json annotations such as JsonIgnore and JsonPropertyName on your dtos work out of the box. customize endpoint name/ swagger operation id the full name (including namespace) of the endpoint classes are used to generate the operation ids. you can change it to use just the class name by doing the following at startup: app.UseFastEndpoints(c => { c.ShortEndpointNames = true; }); custom endpoint names if the auto-generated operation ids are not to your liking, you can specify a name for an endpoint using the WithName() method. public override void Configure() { Get(\"/sales/invoice/{InvoiceID}\"); Description(x => x.WithName(\"GetInvoice\")); } note: when you manually specify a name for an endpoint like above and you want to point to that endpoint when using SendCreatedAtAsync() method, you must use the overload that takes a string argument with which you can specify the name of the target endpoint. i.e. you lose the convenience/type-safety of being able to simply point to another endpoint using the class type like so: await SendCreatedAtAsync<GetInvoiceEndpoint>(...); instead you must do this: await SendCreatedAtAsync(\"GetInvoice\", ...);"
  },
  "wiki/Validation.html": {
    "href": "wiki/Validation.html",
    "title": "request dto validation | FastEndpoints",
    "keywords": "request dto validation request validation is done using FluentValidation rules. please refer to the FluentValidation website if you haven't used it before. just make sure to import it first (or add a global using FluentValidation; in program.cs) before writing any validators. you don't need to install the FluentValidation package as it's automatically brought in by FastEndpoints. simply write your validators by inheriting the Validator<TRequest> base class like below. you don't need to register your validators with the DI container. that is automatically taken care of by FastEndpoints. request dto public class CreateUserRequest { public string FullName { get; set; } public int Age { get; set; } } validator public class MyValidator : Validator<CreateUserRequest> { public MyValidator() { RuleFor(x => x.FullName) .NotEmpty().WithMessage(\"your name is required!\") .MinimumLength(5).WithMessage(\"your name is too short!\"); RuleFor(x => x.Age) .NotEmpty().WithMessage(\"we need your age!\") .GreaterThan(18).WithMessage(\"you are not legal yet!\"); } } if a request is received that doesn't meet the above model validation criteria, a 400 bad request response will be sent to the client automatically with the following json body describing the error details: { \"StatusCode\": 400, \"Message\": \"One or more errors occured!\", \"Errors\": { \"FullName\": [ \"your name is required!\", \"your name is too short!\" ], \"Age\": [ \"we need your age!\", \"you are not legal yet!\" ] } } the format of the error response is customizable as described in the configuration settings page. disable automatic failure response in cases where you need more control of the validations, you can turn off the default behavior by calling the DontThrowIfValidationFails() method in the endpoint configuration like so: public class CreateUserEndpoint : Endpoint<CreateUserRequest> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); DontThrowIfValidationFails(); } } doing so will not send an automatic error response to the client and your handler will be executed. you can check the validation status by looking at the ValidationFailures property of the handler like so: public override async Task HandleAsync(CreateUserRequest req, CancellationToken ct) { if (ValidationFailed) { foreach (ValidationFailure failure in ValidationFailures) { var propertyName = failure.PropertyName; var errorMessage = failure.ErrorMessage; } } await SendOkAsync(); } application logic validation in cases where there are app/business logic validation failures during the processing of a request in the handler, you can send an error response to the client like so: public class CreateUserEndpoint : Endpoint<CreateUserRequest, CreateUserResponse> { public override void Configure() { Verbs(Http.POST); Routes(\"/api/user/create\"); } public override async Task HandleAsync(CreateUserRequest req, CancellationToken ct) { bool userExists = await userRepo.UserAlreadyExists(req.EmailAddress); if (userExists) AddError(r => r.EmailAddress, \"this email is already in use!\"); var maxAge = await userRepo.GetMaxAllowedAge(); if (req.Age >= maxAge) AddError(r => r.Age, \"you are not eligible for insurance!\"); ThrowIfAnyErrors(); //because if there are errors, we shouldn't go beyond this point var userID = await userRepo.CreateNew(req); if (userID is null) ThrowError(\"creating a user did not go so well!\"); //error response thrown here await SendAsync(new CreateUserResponse { UserID = userID, FullName = req.FullName }); } } AddError() - this method adds a validation failure to the ValidationFailures property of the handler. ThrowIfAnyErrors() - this method will cause the handler execution to be halted when called and an error response will be sent to the client if there are any validation failures in the ValidationFailures list. if there's none, execution will proceed to the next line. ThrowError() - this method will abort execution immediately and send an error response to the client. Note by default, validators are used as singletons for performance reasons . i.e. there will only ever be one instance of a validator. all requests to an endpoint will use that single instance for validating the incoming request. so, you should not maintain state in your validators. if you must have state in the validator or would like to do constructor dependency injection by paying the performance penalty, you may do so as shown here ."
  },
  "wiki/VS-Extension.html": {
    "href": "wiki/VS-Extension.html",
    "title": "visual studio new item template | FastEndpoints",
    "keywords": "visual studio new item template if you're doing vertical slice architecture and placing each individual feature in their own namespace, you can take advantage of this vs extension that will add a new item to the \"add new file\" dialog of visual studio to make it convenient for you to add feature file sets to your project. once installed, your visual studio add new item dialog will have FastEndpoints Feature File Set listed under Installed > Visual C# node. then, instead of entering a file name, simply enter the namespace you want your new feature to be added to followed by .cs a new feature file set will then be created in the folder you selected. there will be 4 new files created under the namespace you chose. Data.cs - use this class to place all of your data access logic. Models.cs - place your request, response dtos and the validator in this file. Mapper.cs - domain entity mapping logic will live here. Endpoint.cs - this will be your new endpoint definition. click here for an example feature file set."
  }
}